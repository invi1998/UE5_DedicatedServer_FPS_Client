# 虚幻引擎持久数据大全

旅行、断开连接和在此类场景中持久化数据的汇总

我想你们的游戏中至少已经有两个关卡，玩家可以在一个关卡和另一个关卡之间移动。在玩家到达新关卡后，他们发现以前在旧关卡中拥有的数据已经消失。在其他情况下，由于一些恶劣的网络条件，玩家可能会与服务器断开连接并重新连接，如果处理不当也会导致数据丢失！

##  介绍[Permalink](https://wizardcell.com/unreal/persistent-data/#introduction)

在这篇文章中，我们将讨论在虚幻引擎中的**旅行**和**断开连接**（实际上是一种未启动的旅行）场景。更重要的是，我们将探索几种方法，使我们的数据在这些场景中保持持久。此外，我们还将了解这些方法之间的差异，以及在什么场景下我们应该选择其中一种而不是另一种。

## 旅行：无缝与困难[Permalink](https://wizardcell.com/unreal/persistent-data/#travel-seamless-vs-hard)

在虚幻引擎中，主要有两种旅行方式：**无缝**和**非无缝**，后者也被称为**硬**旅行。主要区别在于，**无缝**旅行由于异步关卡加载是非阻塞操作，而**非无缝**则由于同步关卡加载是阻塞调用。此外，在**非无缝**旅行中，玩家与服务器断开连接，并在新地图同步加载时重新连接，而在**无缝**旅行中，玩家保持连接，但被转移到异步加载的[过渡地图](https://wizardcell.com/unreal/persistent-data/#enabling-seamless-travel-and-transition-map)，直到目标关卡也异步加载完成。

**无缝**旅行应优先于**非无缝**旅行，因为它通常会带来更顺畅的体验，并在客户重新连接时避免一些其他问题。

非无缝旅行必须以三种方式进行：

- 第一次加载地图时
- 作为客户端第一次连接到服务器时（例如，加入会话）
- 当你想结束一场多人游戏并开始一场新游戏时

**注意：**第一种方式并不意味着第一次加载每个新地图，而是初始连接加载的第一个地图。否则，这将意味着我们旅行到的任何新地图都将变成**非无缝**旅行，这是不正确的。

###  旅行类型[Permalink](https://wizardcell.com/unreal/persistent-data/#travel-types)

现在我们了解了虚幻中的旅行方式，让我们了解旅行类型，这可以在这个枚举类中看到：

EngineBaseTypes.h

```C++
Copy code// Traveling from server to server.
UENUM()
enum ETravelType
{
    /**Absolute URL. */
    TRAVEL_Absolute,
    /** Partial (carry name, reset server).*/
    TRAVEL_Partial,
    /** Relative URL. */
    TRAVEL_Relative,
    TRAVEL_MAX,
};
```

让我们解释每种旅行类型及其预期用途：

- **TRAVEL_Relative**（同一服务器，最后的 [选项字符串](https://wizardcell.com/unreal/persistent-data/#7-game-options-string) 被保留）：当前 [网址](https://wizardcell.com/unreal/persistent-data/#url-structure) 相对于最后的网址，因此我们没有与服务器断开连接，这使得它非常适合 **无缝** 旅行。因此，当在客户端进行 **无缝** 旅行时，这种旅行类型是必需的。最后的选项字符串被传递到新级别。
- **TRAVEL_Partial**（服务器重置，尽管保留了最后的选项字符串）：当前的 URL 与最后的 URL 部分匹配，因此我们与服务器断开连接，这对应于 **非无缝** 旅行。最后的选项字符串被传递到新地图。
- **TRAVEL_Absolute**（服务器重置，最后的选项字符串被忽略）：当前的 URL 是绝对的，这意味着最后的 URL（包括最后的选项字符串）被清除，因此我们与服务器断开连接，这对应于 **非无缝** 旅行。

这是一个摘要表，显示每种旅行类型所保留的内容（最后的服务器 URL 和最后的选项字符串），以及是否与**无缝**和**硬性**旅行兼容：

| 旅行类型     |                    保持最后的服务器 URL？                    |                     保持最后选项字符串？                     |                       支持无缝旅行吗？                       |                        支持硬旅行吗？                        |
| :----------- | :----------------------------------------------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
| **Relative** | ![:heavy_check_mark:](https://github.githubassets.com/images/icons/emoji/unicode/2714.png) | ![:heavy_check_mark:](https://github.githubassets.com/images/icons/emoji/unicode/2714.png) | ![:heavy_check_mark:](https://github.githubassets.com/images/icons/emoji/unicode/2714.png) | ![:heavy_check_mark:](https://github.githubassets.com/images/icons/emoji/unicode/2714.png) |
| **Partial**  |                                                              | ![:heavy_check_mark:](https://github.githubassets.com/images/icons/emoji/unicode/2714.png) |                                                              | ![:heavy_check_mark:](https://github.githubassets.com/images/icons/emoji/unicode/2714.png) |
| **Absolute** |                                                              |                                                              |                                                              | ![:heavy_check_mark:](https://github.githubassets.com/images/icons/emoji/unicode/2714.png) |

###  本地旅行司机[Permalink](https://wizardcell.com/unreal/persistent-data/#native-travel-drivers)

有三个主要的本地函数驱动旅行：`UEngine::Browse()`，`UWorld::ServerTravel()`，和 `APlayerController::ClientTravel()` 。在尝试弄清楚使用哪个时，这些可能会有点混淆，因此这里有一些应该有帮助的指导：

#### UEngine::Browse[Permalink](https://wizardcell.com/unreal/persistent-data/#uenginebrowse)

- 就像在加载新地图时进行硬重置。
- 将始终导致不顺畅的旅行。
- 将导致服务器在前往目标地图之前断开当前客户端的连接。
- 客户端将与当前服务器断开连接。
- 专用服务器无法访问其他服务器，因此地图必须是本地的（不能是 URL）。

#### UWorld::ServerTravel[Permalink](https://wizardcell.com/unreal/persistent-data/#uworldservertravel)

-  仅限服务器。
- 将服务器跳转到一个新世界/等级。
- 所有连接的客户端将会跟随。
- 这就是多人游戏从地图到地图移动的方式，服务器负责调用这个功能。
- 服务器将为所有已连接的客户端玩家调用 `APlayerController::ClientTravel()` 。

#### APlayerController::ClientTravel[Permalink](https://wizardcell.com/unreal/persistent-data/#aplayercontrollerclienttravel)

- 如果从客户端调用，将会转移到新服务器。
- 如果从服务器调用，将指示特定客户端前往新地图（但保持与当前服务器的连接）。

###  蓝图旅行司机[Permalink](https://wizardcell.com/unreal/persistent-data/#blueprint-travel-drivers)

在**蓝图**中，推动旅行的两个功能/节点是：

#### OpenLevel[Permalink](https://wizardcell.com/unreal/persistent-data/#openlevel)

- 此功能将始终导致一次**艰难**的旅行（即使**无缝**旅行已[启用](https://wizardcell.com/unreal/persistent-data/#enabling-seamless-travel-and-transition-map)）。
  如果从客户端调用，将会前往新服务器，而不会将其他客户端从服务器断开。如果从监听服务器调用，将会将监听服务器的玩家传送到新地图，断开客户端回到入口/默认地图。如果从专用服务器调用，将导致传送失败，客户端将断开回到默认地图，除非传送 URL 具有“listen”选项，这将指示特定客户端作为监听服务器传送到新地图，但其他客户端将断开回到默认地图。
  它对应于本地函数 `UGameplayStatics::OpenLevel()`，该函数调用 `UEngine::SetClientTravel()`。在下一个时刻，`UGameEngine::Tick()` 调用 `UEngine::Browse()`，后者调用 `UEngine::LoadMap()`。默认情况下 `bAbsolute = true`，使其成为 **绝对** 旅行，否则，它是 **相对**。

**注意：** 在 PIE 中测试旅行（以及许多其他网络功能）应避免，因为这可能会导致您的编辑器崩溃，并且不会反映您的代码在实时中的功能。请坚持在独立/打包的游戏中进行旅行！

#### ExecuteConsoleCommand[Permalink](https://wizardcell.com/unreal/persistent-data/#executeconsolecommand)

- 此功能和`Command`参数为`ServerTravel <MapName>`或`Travel <MapName>`（前者通常使用，因为它可以是**无缝**的，而后者则不能），它们会前往指定的地图，并传递之前设置的选项字符串，分别作为**相对**和**部分**旅行。它们对应于本机功能： `UEngine::HandleServerTravelCommand()` 和 `UEngine::HandleTravelCommand()` 。您可以使用的另一个命令是`Open <MapName>`，它打开指定的地图，而不传递之前设置的选项字符串，因为它是**绝对**旅行。它对应于本机功能`UEngine::HandleOpenCommand()`，该功能调用`UEngine::SetClientTravel()`。在下一个时刻，`UGameEngine::Tick()`调用`UEngine::Browse()`，该功能调用`UEngine::LoadMap()`。这始终是**绝对**旅行。

幸运的是，这些命令在运行时输入到**控制台命令**中时会自动完成：

BaseInput.ini

```C++
Copy code+ManualAutoCompleteList=(Command="Open",Desc="<MapName> Opens the specified map, doesn't pass previously set options")
+ManualAutoCompleteList=(Command="Travel",Desc="<MapName> Travels to the specified map, passes along previously set options")
+ManualAutoCompleteList=(Command="ServerTravel",Desc="<MapName> Travels to the specified map and brings clients along, passes along previously set options")
```

**注意：** 控制台命令不区分大小写，因此可以根据需要书写：全大写/小写、帕斯卡命名法、驼峰命名法等。

### 启用无缝旅行和过渡地图[Permalink](https://wizardcell.com/unreal/persistent-data/#enabling-seamless-travel-and-transition-map)

为了实现无缝旅行，您需要设置一个过渡地图。通过 `UGameMapsSettings.TransitionMap` 属性进行配置。默认情况下，此属性为空，如果您的游戏将此属性留空，则将为过渡地图创建一个空地图。

过渡地图存在的原因是，必须始终加载一个世界（它包含地图），因此我们不能在加载新地图之前释放旧地图。由于地图可能非常大，同时在内存中保留旧地图和新地图是个坏主意，因此这就是过渡地图的作用。

所以现在我们可以从当前地图移动到过渡地图，然后再从那里移动到最终地图。由于过渡地图非常小，它在与当前地图和最终地图重叠时不会增加太多额外开销。

一旦您设置了过渡地图，您将 `AGameModeBase.bUseSeamlessTravel` 设置为 true，从那里无缝旅行应该可以正常工作。

**注意：** 在 5.1 之前，单进程 PIE（编辑器内播放）不支持无缝旅行。因此，您必须关闭[`在一个进程下运行`](https://docs.unrealengine.com/en-US/BuildingWorlds/LevelEditor/InEditorTesting/NetworkedPlayInEditor/#advancedsettings)设置，或者启动一个独立的（右键单击您的 .uproject 文件并选择`启动游戏`），或者启动一个打包的构建。从 5.1 开始，单进程 PIE 支持无缝旅行，但您需要从控制台命令启用[CVar](https://docs.unrealengine.com/en-US/console-varaibles-cplusplus-in-unreal-engine/)`net.AllowPIESeamlessTravel`，因为默认情况下它是禁用的。

## [游戏框架](https://docs.unrealengine.com/4.27/en-US/InteractiveExperiences/Framework/) 对象[Permalink](https://wizardcell.com/unreal/persistent-data/#gameframework-objects)

了解[虚幻游戏框架对象](https://www.tomlooman.com/unreal-engine-gameplay-framework/)及其创建顺序、调用和空间是非常重要的。这将帮助我们解决一系列问题，这些问题不仅仅与持久化数据相关。

**提示：** 从现在开始，你会经常看到 `AGameMode(Base)`，这意味着 `AGameModeBase` 或 `AGameMode`，具体取决于你所继承的类。一般来说，你应该优先选择 `AGameMode`，因为它支持更多的功能：比赛状态、断开连接的记录、**PlayerController** 及其依赖项 **Actors** 的真正持久性等。

### 游戏框架对象创建顺序和调用[Permalink](https://wizardcell.com/unreal/persistent-data/#gameframework-objects-creation-order-and-calls)

大多数情况下，当我们从一个层级旅行到另一个层级（无论类型如何），或者当我们断开连接并重新连接时，**对象** 会被 **销毁** 并 **重新创建**（不包括在游戏开始时创建并在游戏关闭之前从未被销毁的 **GameInstance** 和 **GameViewportClient**），按照以下顺序：

1. **游戏实例：** 在 **独立** 模式下，在游戏启动时在 `UGameEngine::Init()` 中创建一次，而在 **PIE** 模式下，则在每个 PIE 实例中创建。相同的 **游戏实例** 被设置为在新加载的关卡中使用，位于 `UEngine::LoadMap()` 中。
2. **游戏模式：**由**游戏实例**在服务器加载地图时创建，位于 `UGameInstance::CreateGameModeForURL()` ，由`UWorld::SetGameMode()`调用，由`UEngine::LoadMap()`调用。
3. **游戏会话：**由 **游戏模式** 在 `AGameModeBase::InitGame()` 中创建。
4. **游戏状态：**由**游戏模式**在 `AGameModeBase::PreInitializeComponents()` 内部创建。
5. **游戏网络管理器：** 在 `AGameModeBase::PreInitializeComponents()` 内由 **游戏模式** 创建。
6. **玩家控制器：**由 **游戏模式** 创建，通常是在 [成功登录](https://docs.unrealengine.com/4.27/en-US/InteractiveExperiences/Networking/Server/#connectionprocess) 后，在 `AGameModeBase::SpawnPlayerController()` 内部调用，调用者为 `AGameModeBase::Login()`，在 `UWorld::SpawnPlayActor()` 中用于 **硬** 旅行。然而，在 **无缝** 旅行的情况下：如果新的 **游戏模式** 类是 **子类** 的 `AGameMode`**并且** 其 **玩家控制器** 类与之前的 **相同**，那么将保留相同的旧 **玩家控制器**，并且不会创建新的。否则，它们是 **不同** 的类，将在 `AGameMode(Base)::HandleSeamlessTravelPlayer()` 内部创建。
7. **观众棋子:** 由 **玩家控制器** 在 `APlayerController::SpawnSpectatorPawn()` 中创建，调用者为 `APlayerController::BeginSpectatingState()` ，该调用者可能是 `APlayerController::ReceivedPlayer()` ，调用者为 `APlayerController::SetPlayer()` ，在 **硬** 旅行的情况下由 `UWorld::SpawnPlayActor()` 调用，或者由 `APlayerController::ChangeState()` 调用，调用者为 `AGameMode(Base)::InitSeamlessTravelPlayer()` ，调用者为 `AGameMode(Base)::HandleSeamlessTravelPlayer()` 在 **无缝** 旅行的情况下。
   它被摧毁了（当一个 **棋子** 被占有时）在 `APlayerController::DestroySpectatorPawn()` 内，由 `APlayerController::ChangeState()` 调用，由 `APlayerController::OnPossess()` 调用，由 `AController::Possess()` 调用，由 `AGameModeBase::FinishRestartPlayer()` 调用。
8. **玩家状态：** 在 `AController::InitPlayerState()` 中由 **玩家控制器** 创建，玩家情况下由 `APlayerController::PostInitializeComponents()` 调用，在 `AController::InitPlayerState()` 中由 **AI 控制器** 创建，由 `AAIController::PostInitializeComponents()` 调用。
9. **玩家相机管理器：** 由 **玩家控制器** 在 `APlayerController::SpawnPlayerCameraManager()` 中创建，调用者为 `APlayerController::PostInitializeComponents()` ，无论是 **硬** 旅行，还是 **无缝** 旅行，并且新的 **游戏模式****玩家控制器** 类与之前的 **不同**。否则，在 **无缝** 旅行且它们是 **相同** 类的情况下：如果玩家是客户端或监听服务器，则保留相同的旧 **玩家相机管理器**，并且不创建任何新实例。然而，对于专用服务器，它是在 `APlayerController::PostSeamlessTravel()` 中创建的。
10. **作弊管理器:** 由 **玩家控制器** 在 `APlayerController::AddCheats()` 中创建，在 PIE/单人游戏的情况下由 `APlayerController::PostInitializeComponents()` 调用，或者在任何其他情况下但不是发布版本中调用 `EnableCheats()`。
11. **HUD:** 由 **PlayerController** 在 `APlayerController::ClientSetHUD()` 中创建，由 `AGameModeBase::InitializeHUDForPlayer()` 调用，由 `AGameModeBase::GenericPlayerInitialization()` 调用，这适用于 **无缝** 和 **硬** 旅行。在 **无缝** 旅行的情况下，如果新的 **GameMode** 类是 **AGameMode** 的 `子类`**并且** 其 **PlayerController** 类与之前的 **相同**，则旧的 **HUD** 将在 `APlayerController::ClientSetHUD()` 内有效，并将在创建新的 **HUD** 之前被销毁（我们将 [看到下面](https://wizardcell.com/unreal/persistent-data/#persistent-hud-example) 如何处理将旧实例的数据复制到新实例，甚至使其真正持久化）。
12. **棋子：**由 **游戏模式** 在 `AGameModeBase::RestartPlayer()` 中创建，通过 `AGameMode(Base)::HandleStartingNewPlayer()` 调用，可能通过 `AGameMode(Base)::PostLogin()` 在 **硬** 旅行的情况下调用，或者在 **无缝** 旅行的情况下通过 `AGameMode(Base)::HandleSeamlessTravelPlayer()` 调用。
13. **AIController:** 由 AI **Pawn** 在 `APawn::SpawnDefaultController()` 内创建，由 `APawn::PostInitializeComponents()` 调用。

**注意：**我不会提供完整的创建调用栈，也不会提供整个**对象**列表，因为那样太疯狂了，但我会重点介绍一些有趣的。有关更详细的信息，我建议你观看[亚历克斯·福赛思的视频](https://youtu.be/IaU2Hue-ApI)。

**提示：** 使用 `AGameMode(Base)::HandleStartingNewPlayer()` 作为入口函数，因为无论旅行是否顺利，它都会被调用。

### 游戏框架对象创建空间[Permalink](https://wizardcell.com/unreal/persistent-data/#gameframework-objects-creation-space)

**游戏模式**， **游戏会话**， **游戏网络管理器** 和 **AI 控制器** 仅存在于服务器上。

**GameInstance** 和 **GameState** 存在于服务器和客户端，前者没有被复制，而后者被复制。

**玩家状态** 和 **棋子** 是复制的，存在于服务器和客户端的每个（自主和模拟）代理中。

**PlayerController** 是复制的，存在于每个代理的服务器上，仅在拥有客户端（自主代理）上存在。

**PlayerCameraManager** 在服务器上的每个代理中都存在，并且仅在拥有的客户端上存在，但不会被复制。

**观众棋子** 和 **HUD** 仅存在于拥有客户端上。

**CheatManager** 仅存在于服务器上，但如果拥有的客户端调用 `APlayerController::EnableCheats()` ，则可以存在于客户端上。

**注意：** 通常，这些 **演员** 类在两个不同的地图（源地图和目标地图）之间是不同的；因此，如果我们想要持久化数据，我们需要让两个子 **演员** 类继承自一个共享的父 **演员** 类，并将共享的数据放在其中。

## 在无缝旅行中持久化数据[Permalink](https://wizardcell.com/unreal/persistent-data/#persisting-data-across-seamless-travel)

旅行导致我们的大多数**对象**被破坏，这使得持久化运行时数据的过程变得困难。然而，在这种情况下，**无缝**旅行可以让我们的生活变得更加轻松。

###  无缝旅行流程[Permalink](https://wizardcell.com/unreal/persistent-data/#seamless-travel-flow)

1. 标记将持续到过渡级别的**演员**（内部非演员**对象**也将自动持续）。
2. 前往过渡层。
3. 标记将持续到最终级别的**演员**（内部非演员的**对象**也会自动持续）。
4. 前往最后一关。

### 仅在服务器上转换映射的持久对象[Permalink](https://wizardcell.com/unreal/persistent-data/#persistent-objects-on-server-to-transition-map-only)

当我们**无缝**旅行时，这些**对象**将默认保留在过渡地图中：

-  **游戏模式**
-  **游戏会话**
- **GameState**
- 任何非演员的**对象**，如果在之前提到的**演员**内部（即`Object.Outer == Actor`）

请参阅下面的函数以供参考：

GameModeBase.cpp

```C++
Copy codevoid AGameModeBase::GetSeamlessTravelActorList(bool bToTransition, TArray<AActor*>& ActorList)
{
    // Get allocations for the elements we're going to add handled in one go
    const int32 ActorsToAddCount = GameState->PlayerArray.Num() + (bToTransition ? 3 : 0);
    ActorList.Reserve(ActorsToAddCount);

    ...

    if (bToTransition) // true if we are going from old level to transition map, false if we are going from transition map to new level
    {
        // Keep ourselves until we transition to the transition map
        ActorList.Add(this);
        // Keep general game state until we transition to the transition map
        ActorList.Add(GameState);
        // Keep the game session state until we transition to the transition map
        ActorList.Add(GameSession);

        // If adding in this section best to increase the literal above for the ActorsToAddCount
    }
}
```

**注意：**我修正了 if 块内的注释，因为它们最初表示**游戏模式**、**游戏状态**和**游戏会话**会持续到目标地图，这完全是误导性的。此外，请注意[文档](https://docs.unrealengine.com/en-US/InteractiveExperiences/Networking/Travelling/#persistingactorsacrossseamlesstravel)也是误导性的，因为它们实际上也表示**游戏模式**会持续到目标地图，这是不正确的。

#### 它们应该保留在目的地图上吗？[Permalink](https://wizardcell.com/unreal/persistent-data/#should-they-be-kept-to-destination-map)

虽然您可以覆盖上述功能以将这些**演员**保留到目标地图，但我建议您不要这样做，原因有几个：

1. 不应该在 **GameMode** 中持久化运行时数据，因为这个类定义了在编译时设置的游戏规则。

2. **游戏模式** 类通常在两个不同的级别之间变化，因此保持相同的 **演员** 是个坏主意。

3. 保留其中一个类而不保留其他类就像是进入了兔子洞。例如，保留**GameMode**而不保留**GameState**将导致服务器关闭，因为这两个类是耦合的，正如您在这里看到的：

   World.cpp

   ```C++
   Copy code UWorld* FSeamlessTravelHandler::Tick()
    {
        ...
   
        if (KeptGameMode)
        {
            LoadedWorld->CopyGameState(KeptGameMode, KeptGameState);
            bCreateNewGameMode = false;
        }
   
        ...
    }
   
    void UWorld::CopyGameState(AGameModeBase*FromGameMode, AGameStateBase* FromGameState)
    {
        AuthorityGameMode = FromGameMode;
        SetGameState(FromGameState);
    }
   ```

4. 即使我们保留了 **GameMode** 和 **GameState**，我们的游戏也会冻结，并且没有办法解冻它，除非我们重新连接客户端。

**提示：**不要使用这些 **Actor** 类持久化运行时数据： **GameMode**、**GameState** 和 **GameSession**。

### 服务器上的持久对象到目标映射[Permalink](https://wizardcell.com/unreal/persistent-data/#persistent-objects-on-server-to-destination-map)

默认情况下，以下**对象**将仅在**服务器**上持续到目标地图，不过，有时它们会被销毁并重新创建。因此，我们需要将数据（下面会详细说明）复制到新创建的对象上。以下是列表：

- 所有 **PlayerStates**
- 所有**控制器**都有有效的**玩家状态**（包括使用**玩家状态**的**人工智能控制器**）
- 所有 **PlayerControllers**
- 听服务器的 **HUD**
- 听服务器的 **PlayerCameraManager**
- 所有监听服务器的 **用户小部件**
- 任何通过 `APlayerController::GetSeamlessTravelActorList()` 添加的 **演员** 被调用到监听服务器的 **玩家控制器**
- 任何通过 `AGameModeBase::GetSeamlessTravelActorList()` 进一步添加的 **演员**
- 任何不属于演员的**对象**，如果它们在列表中的**演员**内（即在列表`ActorList`中`Object.Outer == Actor`）
- 任何**演员**具有： `(Role < ROLE_Authority) && (NetDormancy < DORM_DormantAll) && (!IsNetStartupActor())`

**注意：** 只有动态 **演员**（分配了动态 [NetGUID](https://docs.unrealengine.com/en-US/API/Runtime/Core/Misc/FNetworkGUID/)，这包括但不限于所有在游戏过程中生成的 **演员**）在 **持久层** 中可能会持续存在。

请参阅下面的功能以供参考：

World.cpp

```C++
Copy codeUWorld* FSeamlessTravelHandler::Tick()
{
    ...

    // mark actors we want to keep
    FUObjectAnnotationSparseBool KeepAnnotation;
    TArray<AActor*> KeepActors;

    if (AGameModeBase* AuthGameMode = CurrentWorld->GetAuthGameMode())
    {
        AuthGameMode->GetSeamlessTravelActorList(!bSwitchedToDefaultMap, KeepActors);
    }

    const bool bIsClient = (CurrentWorld->GetNetMode() == NM_Client);

    // always keep Controllers that belong to players
    if (bIsClient)
    {
        ...
    }
    else
    {
        for( FConstControllerIterator Iterator = CurrentWorld->GetControllerIterator(); Iterator; ++Iterator )
        {
            if (AController* Player = Iterator->Get())
            {
                if (Player->PlayerState || Cast<APlayerController>(Player) != nullptr)
                {
                    KeepAnnotation.Set(Player);
                }
            }
        }
    }

    // ask players what else we should keep
    for (FLocalPlayerIterator It(GEngine, CurrentWorld); It; ++It)
    {
        if (It->PlayerController != nullptr)
        {
            It->PlayerController->GetSeamlessTravelActorList(!bSwitchedToDefaultMap, KeepActors);
        }
    }
    // mark all valid actors specified
    for (AActor* KeepActor : KeepActors)
    {
        if (KeepActor != nullptr)
        {
            KeepAnnotation.Set(KeepActor);
        }
    }

    ...
}
```

GameModeBase.cpp

```C++
Copy codevoid AGameModeBase::GetSeamlessTravelActorList(bool bToTransition, TArray<AActor*>& ActorList)
{
    // Get allocations for the elements we're going to add handled in one go
    const int32 ActorsToAddCount = GameState->PlayerArray.Num() + (bToTransition ? 3 : 0);
    ActorList.Reserve(ActorsToAddCount);

    // Always keep PlayerStates, so that after we restart we can keep players on the same team, etc
    ActorList.Append(GameState->PlayerArray);

    ...
}
```

PlayerController.cpp

```C++
Copy codevoid APlayerController::GetSeamlessTravelActorList(bool bToEntry, TArray<AActor*>& ActorList)
{
    if (MyHUD != NULL)
    {
        ActorList.Add(MyHUD);
    }

    // Should player camera persist or just be recreated?  (clients have to recreate on host)
    ActorList.Add(PlayerCameraManager);
}
```

### 客户端到目标映射的持久对象[Permalink](https://wizardcell.com/unreal/persistent-data/#persistent-objects-on-client-to-destination-map)

默认情况下，以下**对象**将仅在**客户端**上持续到目标地图，尽管有时它们会被销毁并重新创建。因此，我们需要将数据（下面会详细说明）复制到新创建的对象上。以下是列表：

- 本地 **PlayerController**
- **HUD**
- 本地 **PlayerCameraManager**
- 所有 **UserWidgets**
- 任何通过 `APlayerController::GetSeamlessTravelActorList()` 添加的 **演员** 被调用到本地 **玩家控制器**
- 任何不属于演员的**对象**，如果它们在列表中的**演员**内部（即列表中的`Object.Outer == Actor`）
- 任何**演员**具有： `(Role < ROLE_Authority) && (NetDormancy < DORM_DormantAll) && (!IsNetStartupActor())`

**注意：** 只有动态**演员**在**持久层**中才能持久化。

请参阅下面的函数以供参考：

World.cpp

```C++
Copy codeUWorld* FSeamlessTravelHandler::Tick()
{
    ...

    // mark actors we want to keep
    FUObjectAnnotationSparseBool KeepAnnotation;
    TArray<AActor*> KeepActors;

    const bool bIsClient = (CurrentWorld->GetNetMode() == NM_Client);

    // always keep Controllers that belong to players
    if (bIsClient)
    {
        for (FLocalPlayerIterator It(GEngine, CurrentWorld); It; ++It)
        {
            if (It->PlayerController != nullptr)
            {
                KeepAnnotation.Set(It->PlayerController);
            }
        }
    }
    else
    {
        ...
    }

    // ask players what else we should keep
    for (FLocalPlayerIterator It(GEngine, CurrentWorld); It; ++It)
    {
        if (It->PlayerController != nullptr)
        {
            It->PlayerController->GetSeamlessTravelActorList(!bSwitchedToDefaultMap, KeepActors);
        }
    }
    // mark all valid actors specified
    for (AActor* KeepActor : KeepActors)
    {
        if (KeepActor != nullptr)
        {
            KeepAnnotation.Set(KeepActor);
        }
    }

    ...
}
```

PlayerController.cpp

```C++
Copy codevoid APlayerController::GetSeamlessTravelActorList(bool bToEntry, TArray<AActor*>& ActorList)
{
    if (MyHUD != NULL)
    {
        ActorList.Add(MyHUD);
    }

    // Should player camera persist or just be recreated?  (clients have to recreate on host)
    ActorList.Add(PlayerCameraManager);
}
```

### 无缝旅行中的持久非演员对象[Permalink](https://wizardcell.com/unreal/persistent-data/#persistent-non-actor-objects-across-seamless-travel)

**注意：** 本节仍在进行中，因此你不应该轻信我的话！

如果你仔细查看一个像 [docs](https://wizardcell.com/unreal/persistent-data/#5-getseamlesstravelactorlist) 的函数 `GetSeamlessTravelActorList()`，并在字里行间阅读，你会很快意识到，除了持久的 **Actors** 列表外，还有一些非演员的 **Objects** 可能会持久存在，原因是： `(i.e. Object.Outer == Actor in the list)` 。在另一个上下文中，我注意到 **UserWidgets** 仅在 **seamless** 旅行中持久存在，并且它们通常被外部化到 **GameInstance**（如果不存在，则外部化到 **World**），无论旅行类型如何，这都是持久的。一方面，如果某人恰好将他们的 `Outer`（通过 `UObject::Rename()`）更改为 **Pawn**，例如，这在默认情况下不是持久的，那么它们将不再持久；另一方面，将它们的 `Outer` 更改为持久的 **PlayerController** 将使它们保持持久。

这让我得出了以下理论：

> **在无缝旅行中，任何被外部化到持久对象的非演员对象也将是持久的**。

一个假设是，`Outer` 对其内部对象保持强引用，防止它们被自动 [GC’d](https://docs.unrealengine.com/4.27/en-US/ProgrammingAndScripting/ProgrammingWithCPP/UnrealArchitecture/Objects/Optimizations/#garbagecollection)（垃圾回收）。然而，事实并非如此，因此内部 **Object** 的 `Outer` 与该内部对象的生命周期在 GC 角度上没有关系。然而，内部对象对其 `Outer` 保持强引用，因此只要内部对象存活，其 `Outer` 也会被保留。这个规则的一个例外是 **UPackage**。它是实际被引擎保存和加载的根“对象”，因此没有 `Outer`。与该 **Package** 关联的 **Object** 将与其一起被保存，这使得在这种情况下 `Outer` 关系非常重要。

另一个假设是，GC 在无缝旅行时忽略与持久对象外部关联的不可达非 Actor **对象**。不过我还没有证明这是事实。

####  持久用户小部件[Permalink](https://wizardcell.com/unreal/persistent-data/#persistent-userwidgets)

我们已经提到，默认情况下，**UserWidgets** 通常是外部的 **GameInstance**，这就是它们在 **无缝** 旅行中持久存在的原因。话虽如此，看到它们在 **困难** 旅行中的处理方式是相当有趣的。

在一次**艰难**的旅行中，`UEngine::LoadMap()`被调用，并且在某个时刻，委托 `FWorldDelegates::LevelRemovedFromWorld` 被广播。当一个**UserWidget**上调用`UUserWidget::AddToViewport()`时，它内部调用`UUserWidget::AddToScreen()`，这将之前的委托绑定到函数 `UUserWidget::OnLevelRemovedFromWorld()` ，该函数调用 `UUserWidget::RemoveFromParent()` ，如下所示：

UserWidget.h

```C++
Copy code/**
 * Called when a top level widget is in the viewport and the world is potentially coming to and end. When this occurs,
 * it's not safe to keep widgets on the screen. We automatically remove them when this happens and mark them for pending kill.
 */
virtual void OnLevelRemovedFromWorld(ULevel* InLevel, UWorld* InWorld);
```

UserWidget.cpp

```C++
Copy codevoid UUserWidget::OnLevelRemovedFromWorld(ULevel* InLevel, UWorld* InWorld)
{
    // If the InLevel is null, it's a signal that the entire world is about to disappear, so
    // go ahead and remove this widget from the viewport, it could be holding onto too many
    // dangerous actor references that won't carry over into the next world.
    if ( InLevel == nullptr && InWorld == GetWorld() )
    {
        RemoveFromParent();
    }
}
```

当一个 **UserWidget** 被销毁时，其底层的 [**Slate**](https://docs.unrealengine.com/en-US/ProgrammingAndScripting/Slate/InGameUI/)**Widget** 不会自动从视口中移除，因此上述函数 `OnLevelRemovedFromWorld()` 确保了这一点。

总之，在**艰难**旅行中，**UserWidgets**会被销毁，因此它们底层的 Slate **Widget**也会被销毁，而在**无缝**旅行中，它们会很好地保持。

##### 用户小部件是否应该保持无缝旅行？[Permalink](https://wizardcell.com/unreal/persistent-data/#should-userwidgets-persist-seamless-travel)

在阅读前一部分时，您可能会问自己，**UserWidgets** 持久化 **无缝** 旅行是否是一种良好的实践，简短的回答是：不是。原因在于，用户界面（UI）是用于显示状态和接受输入的。使其在关卡加载时保持状态会使其变成状态持有者，而不是显示者。因此，**UserWidgets** 应该大多数情况下是无状态的（除了 **UserWidget** 本身所需的视觉效果），即仅仅是反映其他地方持有的数据，作为回报，它们几乎不需要持久化。

有多种方法可以防止它们持续存在，但这里有两种：

1. 模仿引擎在**困难**旅行中所做的： 重写`UUserWidget::AddToScreen()`（在一个自定义`UserWidgetBase`类中，所有**UserWidget**都继承自该类）并监听委托 `FWorldDelegates::OnSeamlessTravelStart` ，该委托调用一个自定义 `UserWidgetBase::OnSeamlessTravelStart()` ，然后调用一个重写的 `UUserWidgetBase::RemoveFromParent()` 。
2. 当他们的经理 **HUD** 被摧毁时手动移除它们： 在你的 **HUD** 类中重写 `AActor::Destroyed()` （很棒的 **UserWidgets** 管理器），并遍历你的 **UserWidgets**，并显式调用 `UUserWidget::RemoveFromParent()` 。

### 持久对象的意义[Permalink](https://wizardcell.com/unreal/persistent-data/#meaning-of-persistent-objects)

我们已经看到几乎所有的**对象**，包括一些[被提到为持久的对象](https://wizardcell.com/unreal/persistent-data/#persisting-objects-across-seamless-travel)，在我们**无缝**旅行时都会被[销毁并重新创建](https://wizardcell.com/unreal/persistent-data/#gameframework-objects-creation-order-and-calls)。如果是这样，那么前面提到的那些持久**对象**究竟是如何真正持久的呢？

当发生 **无缝** 旅行时，会有一个短暂的时间段，在这个时间段内，特定的 **对象** 类的旧实例和新实例同时存在。在这段时间内，只有你选择从旧实例复制到新实例的数据才会被保留。因此，旧的 **对象** 并不会真正持久化，只有我们选择保留的数据会被保留。然而，这并不总是如此。例如，**用户小部件**（以及任何具有持久 `外部` 的非演员 **对象**）确实会持久化，而无需复制数据。像 **玩家控制器** 和 **玩家相机管理器** 这样的类也是如此，但前提是新的 **游戏模式** 类是 **AGameMode** 的 `子类`**并且** 其 **玩家控制器** 类与之前的 **相同**。我们将 [解释](https://wizardcell.com/unreal/persistent-data/#5-getseamlesstravelactorlist) 其背后的原因以及如何实现。更详细的答案以及数据保留的方式将在接下来的部分中找到。

## 在断开连接时持久化数据[Permalink](https://wizardcell.com/unreal/persistent-data/#persisting-data-across-disconnects)

虽然现代互联网使玩家能够在全球范围内相互连接，但互联网有时并不像我们希望的那样稳定。在多人游戏中，断线每天都会发生，如果处理不当，玩家将会受到影响。断开连接和重新连接是[按定义](https://wizardcell.com/unreal/persistent-data/#travel-seamless-vs-hard)的**困难**旅行，这意味着我们缺乏上述讨论的**无缝**旅行持久数据的好处。幸运的是，虚幻引擎已经内置了处理断开连接和重新连接玩家数据保持的功能。要了解这个功能是如何一起工作的，我们首先应该理解引擎是如何处理断开连接的玩家的。

### 断开连接时存储数据[Permalink](https://wizardcell.com/unreal/persistent-data/#storing-data-on-disconnection)

这是一个断开连接的玩家的调用栈（按顺序），直到他的数据被保存的点：

```C++
Copy code1. APlayerController::Destroyed()
2. AController::Destroyed()
3. AGameMode::LogOut()
4. AGameMode::AddInactivePlayer()
5. APlayerState::Duplicate()
6. APlayerState::DispatchCopyProperties()
7. APlayerState::CopyProperties(), APlayerState::ReceiveCopyProperties() // Native and Blueprint
```

**注意：**您的 **GameMode** 自定义类必须继承自 `AGameMode` 而不是 `AGameModeBase`，因为后者不支持此功能。

现在用文字描述，当玩家与游戏服务器断开连接时会发生什么：

1. 他的 **Pawn** 从 **PlayerController** 中被移除，并在 `APlayerController::PawnLeavingGame()` 内被销毁。**SpectatorPawn**、**HUD** 和 **PlayerCameraManager** 也都被销毁。

2. 一个新的“副本” **PlayerState** 被生成，数据从旧的原始 **PlayerState** 复制到新创建的副本中，这些数据在本地和蓝图 `CopyProperties()` 函数中指定。覆盖其中一个，并根据需要决定要复制哪些数据。以下是默认复制的数据：

   PlayerState.cpp

   ```C++
   Copy code void APlayerState::CopyProperties(APlayerState* PlayerState)
    {
        PlayerState->SetScore(GetScore());
        PlayerState->SetCompressedPing(GetCompressedPing());
        PlayerState->ExactPing = ExactPing;
        PlayerState->SetPlayerId(GetPlayerId());
        PlayerState->SetUniqueId(GetUniqueId());
        PlayerState->SetPlayerNameInternal(GetPlayerName());
        PlayerState->SetStartTime(GetStartTime());
        PlayerState->SavedNetworkAddress = SavedNetworkAddress;
    }
   ```

3. 新的副本 **PlayerState** 被停用（不再复制），其生命周期设置为 `AGameMode.InactivePlayerStateLifeSpan` ，默认是 300 秒。如果玩家在此时间内没有重新连接，他们的非活动存储副本 **PlayerState** 将被销毁，并且他们将无法再次连接（因为他们的 `UniqueId` 或 `SavedNetworkAddress` 丢失）。将 `InactivePlayerStateLifeSpan` 设置为 0 将清除计时器，存储副本 **PlayerState** 将不会被销毁。非活动的 **PlayerState** 被添加到 `AGameMode.InactivePlayerArray`，这是一个属于已从服务器断开连接的玩家的 **PlayerStates** 数组，以便在他们重新连接时保存。请注意，`AGameMode.MaxInactivePlayers` 决定在踢出较旧的玩家之前，最多可以有多少个断开连接的玩家。

4. 原始 **PlayerState** 然后在 `APlayerState::OnDeactivated()` 中被销毁，该函数由 `APlayerController::CleanupPlayerState()` 调用，进而将其从 `AGameStateBase.PlayerArray`（所有活动 **PlayerStates** 的数组）中移除，位于 `APlayerState::Destroyed()` 中。拥有的 **PlayerController** 随后被销毁。

**注意：** 默认情况下，**PlayerState** 被复制的条件之一是如果 `APlayerState.bOnlySpectator == false` 对于断开连接的玩家，这意味着他没有作为 [观众](https://wizardcell.com/unreal/spectating-system/) 加入服务器。

话虽如此，还有两个陷阱，我们将在下一节中讨论。

###  陷阱[Permalink](https://wizardcell.com/unreal/persistent-data/#the-pitfalls)

**(1)** 感谢我的朋友 [Zlo](https://www.linkedin.com/in/josip-duvancic-933934254/) 对第一个陷阱的见解。引用他的话：

> 虽然看起来 `APlayerState::CopyProperties()` 是在断开连接时存储任何数据的功能，但实际上并不是，因为您可能需要提取一些与棋子相关的数据，而为了在重新连接时正确恢复，这个功能无法做到。
>
> 例如，假设您希望断开的棋子在断开时重新出现在它们断开的地方。这要求**PlayerState**在玩家断开时知道**棋子**的位置，但它通常并不知道。您的库存或技能系统也是如此，即使您有先见之明将它们放入**PlayerState**类中，`CopyProperties()`仍然是一个问题。
>
> 为了使`CopyProperties()`正常工作，**PlayerState**必须已经拥有你所需的所有数据，而出于断开连接的目的，它通常没有。因此，你需要一个在稍后时间被调用的函数。`APlayerState::OnDeactivated()`就是这个函数。

PlayerState.h

```C++
Copy code/** Called on the server when the owning player has disconnected, by default this method destroys this player state */
virtual void OnDeactivated();
```

**(2)** 虽然一个 **Actor** 拥有自己的 [**AbilitySystemComponent**](https://docs.unrealengine.com/5.0/en-US/gameplay-ability-system-component-and-gameplay-attributes-in-unreal-engine/) 是很常见的，但在某些情况下，您可能希望一个 **Actor**，例如玩家的 **Pawn**，使用由另一个 **Actor** 拥有的 **AbilitySystemComponent**，比如 **PlayerState** 或 **PlayerController**。这样做的原因可能包括玩家的得分，或者在玩家的 **Pawn** 被摧毁并重生时，或当玩家拥有一个新的 **Pawn** 时，长时间的能力冷却计时器不会重置。

出于上述原因以及断开连接的目的，我们将把 **AbilitySystemComponent** 附加到 **PlayerState**。然而，一旦我们尝试复制我们的 **PlayerState**，我们会发现 **AbilitySystemComponent** 的 **AttributeSets** 被设置为 `nullptr` 而不是正确的值，结果证明这是一个 [引擎错误](https://issues.unrealengine.com/issue/UE-81109)。虽然对此有 [解决方法](https://github.com/tranek/GASDocumentation#94-duplicating-blueprint-actors-is-setting-attributesets-to-nullptr)，但在我看来，正确且简单的解决方案是让我们的原始 **PlayerState** 保持不变，而不创建任何副本。这也节省了我们在复制与 **PlayerState** 相关的属性到副本上所花费的时间，特别是当它们太多时，使我们更不容易出错。

### 在断开连接时存储数据的更好、更可靠的方法[Permalink](https://wizardcell.com/unreal/persistent-data/#the-better-more-reliable-way-to-stash-data-on-disconnection)

虽然您想在断开连接时存储的属性可能散布在**PlayerState**类的各个地方，但更好的、优化的方式是使用结构体将它们封装起来。这样，即使有一大堆我们想要保存的数据，我们仍然可以相对快速地引用它们。

PlayerState.h

```C++
Copy code// Disconnected hero's non-PlayerState related data will be stored here
USTRUCT()
struct FDisconnectedHeroData
{
    GENERATED_BODY()

public:

    /** Hero's transform (location, rotation, scale) */
    UPROPERTY()
    FTransform Transform;

    /** Hero's health */
    UPROPERTY()
    int32 Health;
};

UCLASS()
class AMyPlayerState: public APlayerState
{
    GENERATED_BODY()

public:
    /** Disconnected player's stashed data, so we reapply it on reconnection */
    UPROPERTY()
    FDisconnectedHeroData DisconnectedHeroData;

    ...

};
```

为了让我们能够在 `APlayerState::OnDeactivated()` 中提取与棋子相关的数据，棋子必须在那时是有效的并且被占有。然而，**Pawn** 在 `APlayerState::OnDeactivated()` 或甚至 `APlayerState::CopyProperties()` 被调用之前是未被占有并且被销毁的。具体来说，它在以下函数中被销毁：

PlayerController.cpp

```C++
Copy codevoid APlayerController::Destroyed()
{
    if (GetPawn() != NULL)
    {
        // Handle players leaving the game
        if (Player == NULL && GetLocalRole() == ROLE_Authority)
        {
            PawnLeavingGame(); // Destroys our pawn
        }
        else
        {
            UnPossess(); // Unpossess our pawn, nulling out APlayerState.PawnPrivate
        }
    }

    ...

    Super::Destroyed();
}
```

因此，我们必须重写该函数，以既不销毁**Pawn**也不解除其占有，而是将功能委托给`APlayerState::OnDeactivated()`，该函数将在稍后的阶段被调用：

MyPlayerController.cpp

```C++
Copy codevoid AMyPlayerController::Destroyed()
{
    if (GetSpectatorPawn() != NULL)
    {
        DestroySpectatorPawn();
    }

    if ( MyHUD != NULL )
    {
        MyHUD->Destroy();
        MyHUD = NULL;
    }

    if (PlayerCameraManager != NULL)
    {
        PlayerCameraManager->Destroy();
        PlayerCameraManager = NULL;
    }

    // Tells the game info to forcibly remove this player's CanUnpause delegates from its list of Pausers.
    // Prevents the game from being stuck in a paused state when a PC that paused the game is destroyed before the game is unpaused.
    AGameModeBase* const GameMode = GetWorld()->GetAuthGameMode();
    if (GameMode)
    {
        GameMode->ForceClearUnpauseDelegates(this);
    }

    PlayerInput = NULL;
    CheatManager = NULL;

    Super::Super::Destroyed(); // or AController::Destroyed();
}
```

接下来，我们重写 `AGameMode::AddInactivePlayer()` ，以便它不会重复我们的原始 **PlayerState**（即 `APlayerState::Duplicate()` 不会被调用， `APlayerState::CopyProperties()` 也相应地），而是让它保留：

MyGameMode.h

```C++
Copy code/** Add PlayerState to the inactive list, remove from the active list */
virtual void AddInactivePlayer(APlayerState* PlayerState, APlayerController* PC) override;
```

MyGameMode.cpp

```C++
Copy codevoid AMyGameMode::AddInactivePlayer(APlayerState* PlayerState, APlayerController* PC)
{
    check(PlayerState)
    UWorld* LocalWorld = GetWorld();
    // don't store if it's an old PlayerState from the previous level or if it's a spectator... or if we are shutting down
    if (!PlayerState->IsFromPreviousLevel() && !MustSpectate(PC) && !LocalWorld->bIsTearingDown)
    {
        // We remove the PlayerState from the active PlayerArray as it's going to stick around (see APlayerState::Destroyed)
        GameState->RemovePlayerState(PlayerState);

        // make PlayerState inactive
        PlayerState->SetReplicates(false);

        // delete after some time
        PlayerState->SetLifeSpan(InactivePlayerStateLifeSpan);

        // On console, we have to check the unique net id as network address isn't valid
        const bool bIsConsole = !PLATFORM_DESKTOP;
        // Assume valid unique ids means comparison should be via this method
        const bool bHasValidUniqueId = PlayerState->GetUniqueId().IsValid();
        // Don't accidentally compare empty network addresses (already issue with two clients on same machine during development)
        const bool bHasValidNetworkAddress = !PlayerState->SavedNetworkAddress.IsEmpty();
        const bool bUseUniqueIdCheck = bIsConsole || bHasValidUniqueId;

        // make sure no duplicates
        for (int32 Idx = 0; Idx < InactivePlayerArray.Num(); ++Idx)
        {
            APlayerState* const CurrentPlayerState = InactivePlayerArray[Idx];
            if (!IsValid(CurrentPlayerState))
            {
                // already destroyed, just remove it
                InactivePlayerArray.RemoveAt(Idx, 1);
                Idx--;
            }
            else if ((!bUseUniqueIdCheck && bHasValidNetworkAddress && (CurrentPlayerState->SavedNetworkAddress ==
                    PlayerState->SavedNetworkAddress))
                || (bUseUniqueIdCheck && (CurrentPlayerState->GetUniqueId() == PlayerState->GetUniqueId())))
            {
                // destroy the PlayerState, then remove it from the tracking
                CurrentPlayerState->Destroy();
                InactivePlayerArray.RemoveAt(Idx, 1);
                Idx--;
            }
        }
        InactivePlayerArray.Add(PlayerState);

        // make sure we don't go over the maximum number of inactive players allowed
        if (InactivePlayerArray.Num() > MaxInactivePlayers)
        {
            int32 const NumToRemove = InactivePlayerArray.Num() - MaxInactivePlayers;

            // destroy the extra inactive players
            for (int Idx = 0; Idx < NumToRemove; ++Idx)
            {
                APlayerState* const PS = InactivePlayerArray[Idx];
                if (PS != nullptr)
                {
                    PS->Destroy();
                }
            }

            // and then remove them from the tracking array
            InactivePlayerArray.RemoveAt(0, NumToRemove);
        }
    }
}
```

接下来，我们重写 `APlayerState::OnDeactivated()`，该方法默认会销毁我们原来的 **PlayerState**，因此它不会这样做，并且我们将专门填充我们的 `FDisconnectedHeroData` 结构体：

MyPlayerState.cpp

```C++
Copy codevoid AMyPlayerState::OnDeactivated()
{
    if (const AMyPawn* MyPawn = GetPawn<AMyPawn>())
    {
        DisconnectedHeroData.Transform = MyPawn->GetTransform();
        DisconnectedHeroData.Health = MyPawn->GetHealth();
        // Further pawn-related data can be pulled and stashed in here
    }

    if (APlayerController* PC = GetPlayerController())
    {
        // Handle players leaving the game
        if (!PC->Player)
        {
            PC->PawnLeavingGame();
        }
        else
        {
            PC->UnPossess();
        }
    }
}
```

最后但并非最不重要的是，当一个 [玩家重新登录](https://docs.unrealengine.com/4.27/en-US/InteractiveExperiences/Networking/Server/#connectionprocess) 时，我们需要判断他是否是一个重新连接的玩家，因此我们会在他之前的 **变形** 处重新生成他：

MyPlayerState.h

```C++
Copy codeprivate:
/** Means this PlayerState belongs to a reconnecting player */
uint8 bIsReconnecting:1;

public:
/** Gets the literal value of bIsReconnecting. */
bool IsReconnecting() const
{
    return bIsReconnecting;
}

/** Called on the server when the owning player has reconnected and this player state is added to the active players array */
virtual void OnReactivated() override;
```

MyPlayerState.cpp

```C++
Copy codevoid AMyPlayerState::OnReactivated()
{
    bIsReconnecting = true;
}
```

默认情况下，新玩家总是会在一个 **PlayerStart** 处生成。相反，我们让他在他的旧 **Transform** 处生成，以防他正在重新连接：

MyGameMode.h

```C++
Copy code/** Tries to spawn the player's pawn, either at his old location in case he's reconnecting, or at the location returned by FindPlayerStart */
virtual void RestartPlayer(AController* NewPlayer) override;
```

MyGameMode.cpp

```C++
Copy codevoid AMyGameMode::RestartPlayer(AController* NewPlayer)
{
    if (NewPlayer == nullptr || NewPlayer->IsPendingKillPending())
    {
        return;
    }

    const AMyPlayerState* PS = NewPlayer->GetPlayerState<AMyPlayerState>();
    if(PS && PS->IsReconnecting())
    {
        RestartPlayerAtTransform(NewPlayer, PS->DisconnectedHeroData.Transform);
    }
    else
    {
        AActor* StartSpot = FindPlayerStart(NewPlayer);

        // If a start spot wasn't found,
        if (StartSpot == nullptr)
        {
            // Check for a previously assigned spot
            if (NewPlayer->StartSpot != nullptr)
            {
                StartSpot = NewPlayer->StartSpot.Get();
                UE_LOG(LogGameMode, Warning, TEXT("RestartPlayer: Player start not found, using last start spot"));
            }
        }

        RestartPlayerAtPlayerStart(NewPlayer, StartSpot);
    }
}
```

### 重新连接时恢复数据[Permalink](https://wizardcell.com/unreal/persistent-data/#restoring-data-on-reconnection)

这是重新连接的玩家的调用栈（按顺序），直到他的数据被覆盖的点：

```C++
Copy code1. UWorld::SpawnPlayActor()
2. AGameMode::Login(), AGameMode::PostLogin()
3. AGameMode::FindInactivePlayer()
4. AGameMode::OverridePlayerState()
5. APlayerState::DispatchOverrideWith()
6. APlayerState::OverrideWith(), APlayerState::ReceiveOverrideWith() // Native and Blueprint
```

现在用文字来说，这就是当玩家重新登录游戏服务器时发生的[事情](https://wizardcell.com/unreal/persistent-data/#gameframework-objects-creation-order-and-calls)的一部分：

1. 一个新的 **PlayerController** 和 **Pawn**（由前者控制）被 **GameMode** 为他重新创建。
2. 一个新的 **PlayerState**、**PlayerCameraManager** 和 **HUD** 被 **PlayerController** 为他重新创建。
3. 原始的非活动 **PlayerState**`CurrentPlayerState` 被检索并设置为我们使用的 **PlayerState**。然后它被我们新创建的 **PlayerController** 所拥有，重新激活，生命周期计时器被清除，并设置为不被销毁。
4. 现在查看本地变量 `OldPlayerState`，顾名思义，可以猜测它被赋值为旧的/原始的非活动 **PlayerState**。这种假设更为合理的原因是它被传递给了 `AGameMode::OverridePlayerState()` ，而 `AGameMode::OverridePlayerState()` 又在某个时刻将其传递给了 `APlayerState::ReceiveOverrideWith()` ，其文档建议如下：

PlayerState.h

```C++
Copy code/*
 * Can be implemented in Blueprint Child to move more properties from old to new PlayerState when reconnecting
 *
 * @param OldPlayerState     Old PlayerState, which we use to fill the new one with
 */
UFUNCTION(BlueprintImplementableEvent, Category = PlayerState, meta = (DisplayName = "OverrideWith"))
void ReceiveOverrideWith(APlayerState* OldPlayerState);
```

实际上，局部变量 `OldPlayerState` 被分配了新生成的“空” **PlayerState**。因此， `AGameMode::OverridePlayerState()` 在我们原本刚激活的 **PlayerState** 上被调用，传入了“毫无意义”生成的、几乎为空的 **PlayerState**。以下是这个过程中的覆盖内容：

PlayerState.cpp

```C++
Copy codevoid APlayerState::OverrideWith(APlayerState* PlayerState)
{
    SetIsSpectator(PlayerState->IsSpectator());
    SetIsOnlyASpectator(PlayerState->IsOnlyASpectator());
    SetUniqueId(PlayerState->GetUniqueId());
    SetPlayerNameInternal(PlayerState->GetPlayerName());
}
```

正如你所看到的，被覆盖的内容是如此微不足道，以至于它很可能对重新连接过程很重要。
理论上，您可以使用此功能覆盖其他类型的数据，这些数据在玩家重新连接时可能已经过时。例如，当团队交换位置时。如果这种情况处理不当，重新连接的玩家可能会发现自己在错误的团队中！

最后，几乎空的 `OldPlayerState` 然后调用 `SetIsInactive(true)`，这又调用了 `APlayerState::OnRep_bIsInactive()` ，阻止它与 `AGameStateBase.PlayerArray` 注册。 `OldPlayerState` 随后被销毁，而原来的刚刚重新激活的 **PlayerState** 调用 `APlayerState::OnReactivated()`，默认情况下什么也不做，尽管我们在上面很好地利用了它。

**注意：** 不幸的是，目前将玩家与他们之前的 **PlayerState** 匹配的方法是通过比较他们的 IP 地址。如果多个玩家使用相同的远程 IP 地址进行游戏，错误的玩家可能会接管他们网络上另一个断开连接的玩家。奇怪的是，这不会影响控制台版本，因为它们会检查玩家的 `PlayerState.UniqueId`（在 **OnlineSubsystems** 中称为 `UniqueNetId`），这是一个更好的唯一标识符。默认的 OSS 是 **OnlineSubsystemNull**，它没有有效的 `UniqueNetId`，这就是为什么需要一个具有唯一用户的后端，即 `APlayerState::GetUniqueId()` 只有在加载了像 **Steam** 或 **EOS** 这样的 OSS 时才相关/一致。

### 如何断开/重新连接？[Permalink](https://wizardcell.com/unreal/persistent-data/#how-to-disconnectreconnect)

理论上，实现这些功能可能有多种方式。幸运的是，虚幻引擎已经将这些功能实现为控制台命令。我们在控制台命令行中输入的一些命令在以下函数中的某个时刻被解析：

UnrealEngine.cpp

```C++
Copy codebool UEngine::Exec( UWorld*InWorld, const TCHAR* Cmd, FOutputDevice& Ar )
{
    ...

    else if( FParse::Command( &Cmd, TEXT("DISCONNECT")) )
    {
        return HandleDisconnectCommand( Cmd, Ar, InWorld );
    }
    else if( FParse::Command( &Cmd, TEXT("RECONNECT")) )
    {
        return HandleReconnectCommand( Cmd, Ar, InWorld );
    }

    ...
}
```

- **断开连接**: 将客户端从当前游戏/服务器断开连接。它对应于本机函数 `UEngine::HandleDisconnectCommand()` ，该函数调用 `UEngine::HandleDisconnect()`。断开连接实际上是一种 **绝对** 或 **部分** 类型的旅行（取决于断开连接的情况），在任何情况下都会导致 **硬** 旅行。
- **重新连接**: 将客户端重新连接到当前游戏/服务器。它对应于原生函数 `UEngine::HandleReconnectCommand()` 。断开连接实际上是一种 **绝对** 类型的旅行，导致 **硬** 旅行。

**注意：**这些命令不像我们之前看到的与旅行相关的命令那样自动完成，因为它们没有设置 `ManualAutoCompleteList`。

这里有几个地方可以选择，以在代码中执行上述功能：

- `UKismetSystemLibrary::ExecuteConsoleCommand()` 本地函数（蓝图版本具有相同名称）和 `Command` 参数可以是 `DISCONNECT` 或 `RECONNECT`。
- `UGameInstance::Exec()` 函数和 `Cmd` 参数可以是 `DISCONNECT` 或 `RECONNECT`。

##  持久运行时数据[Permalink](https://wizardcell.com/unreal/persistent-data/#persistent-runtime-data)

幸运的是，在保存我们在级别变化或重新连接时的数据时，有多个选项可以考虑。请注意，每个选项中的**使用**部分反映了我自己的观点；因此，您可以偏离脚本。作为一个经验法则，我倾向于将服务器权威数据存储在服务器端，而将客户端权威数据存储在客户端。然而，有时服务器权威数据直观上存储在客户端，这迫使我们在检索数据并在应用之前进行验证。

## 1. GameInstance[Permalink](https://wizardcell.com/unreal/persistent-data/#1-gameinstance)

**游戏实例**是一个高层管理**对象**，用于运行游戏的实例。在游戏创建时生成，直到游戏实例关闭才会被销毁。换句话说，**游戏实例**在每个关卡之间持续存在，无论旅行类型如何，这使得它成为保存数据的良好候选者。作为独立游戏运行时，将会有一个这样的实例。在 PIE 中运行时，每个 PIE 实例将生成一个这样的实例。

### 如何指定我的自定义类？[Permalink](https://wizardcell.com/unreal/persistent-data/#how-to-specify-my-custom-class)

您已经可以判断它不应该在您的自定义**游戏模式**的`类默认值`中的`类`类别，因为**游戏实例**不是特定于关卡的，因此它与**游戏模式**无关。

要配置您的项目以使用您所需的自定义 **GameInstance**，请查看 `Project Settings->Maps & Modes` ，您应该在最底部看到这个：

![GameInstance Configuration](https://wizardcell.com//assets/blog/persistent-data/game-instance-configuration.png)

### 这个Class在哪里存在？[Permalink](https://wizardcell.com/unreal/persistent-data/#where-does-this-class-exist)

这个类在服务器和客户端都存在，但它是不可复制的；因此，您无法复制这个类中的任何数据。

###  保存和检索数据[Permalink](https://wizardcell.com/unreal/persistent-data/#saving--retrieving-data)

这可能是最简单的方法，因为您只需在旅行到新关卡之前保存数据，然后在完成该关卡的旅行后检索保存的数据。至于断开连接，情况并没有什么不同。重新连接的玩家实际上是在旅行到他之前所在的地图。我们已经[看到](https://wizardcell.com/unreal/persistent-data/#the-pitfalls) `APlayerState::OnDeactivated()` 是在断开连接时保存数据的一个好时机；因此，在那里提取您需要的数据，并将其挂接到您的**GameInstance**中。当客户端断开连接时，他的客户端**GameInstance**仍然保留在他自己本地机器的内存中。在重新连接时，可以检索、验证并在需要的地方重新应用数据。

###  使用情况[Permalink](https://wizardcell.com/unreal/persistent-data/#usage)

- 在**艰难**旅行之间保持世界状态数据。
- 在断开连接时存储特定于玩家的数据，并在重新连接时检索它。

**提示：**考虑使用[下一个选项](https://wizardcell.com/unreal/persistent-data/#2-programming-subsystems)。

## 2. 编程子系统[Permalink](https://wizardcell.com/unreal/persistent-data/#2-programming-subsystems)

在虚幻引擎中，子系统是具有管理生命周期的自动实例化类。这些类提供了易于使用的扩展点，程序员可以立即获得蓝图和 Python 的接触，同时避免修改或重写引擎类的复杂性。子系统不支持网络，因此您不应该直接在其中复制任何数据。有关它们的更多信息，以及它们为何有用，可以在[官方文档](https://docs.unrealengine.com/4.27/en-US/ProgrammingAndScripting/Subsystems/)或[benui 的博客文章](https://benui.ca/unreal/subsystem-singleton/)中找到。

### 这个Class在哪里存在？[Permalink](https://wizardcell.com/unreal/persistent-data/#where-does-this-class-exist-1)

正如您可能已经看到的，有 5 种不同的父类可供选择。不过，我们将重点介绍在此上下文中使用的：**GameInstance**和**LocalPlayer**子系统。两者的生命周期几乎相似（但不完全相同），与[**GameInstance**](https://wizardcell.com/unreal/persistent-data/#1-gameinstance)的生命周期相同，这意味着它们在旅行和断开连接时都会保持。

**GameInstance** 子系统在服务器和客户端都存在，但如前所述，它是不可复制的，即两个版本不一定是同步的。

**LocalPlayer** 子系统为每个 **LocalPlayer** 存在。这意味着在监听服务器设置中，它存在于服务器上供监听服务器（主机）玩家使用，并在客户端上供其他客户端（托管）玩家使用。在专用服务器设置中，它不会存在于服务器上，而只存在于每个客户端上。

###  保存和检索数据[Permalink](https://wizardcell.com/unreal/persistent-data/#saving--retrieving-data-1)

在这种情况下，保存和检索数据与在 [**GameInstance**](https://wizardcell.com/unreal/persistent-data/#storing--retrieving-data) 中的方式没有任何不同，因为提到的子系统与 **GameInstance** 的生命周期相似（它们存在于 [`UWorlds`](https://docs.unrealengine.com/5.0/en-US/API/Runtime/Engine/Engine/UWorld/) 之外），使它们在旅行或断开连接时成为持久化数据的更好选择。原因是使用 **GameInstance** 来持久化数据可能会迅速膨胀，使得处理其他 **Objects**（如 **Sessions**、**SaveGames** 等）变得不那么理想。

###  使用情况[Permalink](https://wizardcell.com/unreal/persistent-data/#usage-1)

- 保持最佳的 **GameInstance**。

####  游戏实例子系统[Permalink](https://wizardcell.com/unreal/persistent-data/#gameinstance-subsystem)

- 在**艰难**旅行之间保持世界状态数据。
- 在断开连接时存储特定于玩家的数据，并在重新连接时检索它。

#####  示例用法[Permalink](https://wizardcell.com/unreal/persistent-data/#example-usage)

[统计系统](https://docs.unrealengine.com/4.27/en-US/ProgrammingAndScripting/Subsystems/#subsystemsexample)，用于跟踪收集的资源数量。

####  本地玩家子系统[Permalink](https://wizardcell.com/unreal/persistent-data/#localplayer-subsystem)

- 在**艰难**旅行之间保持与玩家特定和本地玩家相关的数据（例如 UI、输入等）。
- 在断开连接时存储特定于玩家和本地玩家相关的数据，并在重新连接时检索它。

#####  示例用法[Permalink](https://wizardcell.com/unreal/persistent-data/#example-usage-1)

[增强输入](https://docs.unrealengine.com/en-US/enhanced-input-in-unreal-engine/)**本地玩家**子系统 ([ `UEnhancedInputLocalPlayerSubsystem` ](https://github.com/EpicGames/UnrealEngine/blob/release/Engine/Plugins/Experimental/EnhancedInput/Source/EnhancedInput/Public/EnhancedInputSubsystems.h))，它将允许您添加映射上下文、绑定输入委托等。

**注意：**不要将 [**编程子系统**](https://docs.unrealengine.com/4.27/en-US/ProgrammingAndScripting/Subsystems/) 与 [**在线子系统**](https://docs.unrealengine.com/en-US/online-subsystem-in-unreal-engine/) 混淆，因为它们是不同的实体。

## 3. PlayerState[Permalink](https://wizardcell.com/unreal/persistent-data/#3-playerstate)

每个服务器（或独立游戏）上的玩家都会创建一个 **PlayerState**。 **PlayerStates** 是相关的，并复制到所有客户端，包含关于玩家的网络游戏相关信息，例如他的名字、得分、延迟等。

### 这个Class在哪里存在？[Permalink](https://wizardcell.com/unreal/persistent-data/#where-does-this-class-exist-2)

这个类 **Actor** 存在于服务器上，复制到所有客户端，并且始终是相关的 (`bAlwaysRelevant = true`)。因此，每个客户端始终知道他的 **PlayerState** 以及所有其他客户端的状态。

###  复制数据[Permalink](https://wizardcell.com/unreal/persistent-data/#copying-data)

数据从旧实例的这个**演员**复制到新的实例，发生在**无缝旅行**或**断开连接**时。这两个过程都在服务器上进行。

###  使用情况[Permalink](https://wizardcell.com/unreal/persistent-data/#usage-2)

- 在**无缝**旅行之间保持玩家特定数据。
- 在断开连接时存储特定于玩家的数据，并在重新连接时检索它。

###  示例用法[Permalink](https://wizardcell.com/unreal/persistent-data/#example-usage-2)

假设我们有一个自定义的 **PlayerState**，其中包含一些自定义成员变量：

MyPlayerState.h

```C++
Copy code// Seamless traveled hero's non-PlayerState related data will be stored here
USTRUCT()
struct FSeamlessTraveledHeroData
{
    GENERATED_BODY()

    /** Player's current selected hero to respawn as */
    UPROPERTY()
    TSubclassOf<APawn> SelectedHero;
}

UCLASS()
class AMyPlayerState: public APlayerState
{
    GENERATED_BODY()

public:
    /** Player's current kill count */
    UPROPERTY(Transient, Replicated)
    int32 Kills;

    /** Player's current assist count */
    UPROPERTY(Transient, Replicated)
    int32 Assists;

    /** Player's current death count */
    UPROPERTY(Transient, Replicated)
    int32 Deaths;

    /** Seamless traveled player's stored data, so we reapply it when player has finished loading */
    UPROPERTY()
    FSeamlessTraveledHeroData SeamlessTraveledHeroData;

    ...

};
```

默认情况下，当玩家**无缝**旅行（或断开连接）时，这些属性都不会被保留。要解决此问题，我们需要重写以下函数：

PlayerState.h

```C++
Copy code/** Copy properties which need to be saved in inactive PlayerState */
virtual void CopyProperties(APlayerState* PlayerState);
```

请注意，这与我们之前讨论的功能相同，[在断开连接时保留一些数据](https://wizardcell.com/unreal/persistent-data/#storing-data-on-disconnection)。正如我们之前所见，只有一小部分内置属性被保留，而我们自定义的属性不幸的是没有被保留，因此我们必须自己处理。

MyPlayerState.cpp

```C++
Copy codevoid AMyPlayerState::CopyProperties(APlayerState* PlayerState)
{
    Super::CopyProperties(PlayerState); // This is called so we preserve data chosen to be preserved by default

    if (AMyPlayerState* NewPlayerState = Cast<AMyPlayerState>(PlayerState))
    {
        NewPlayerState->SeamlessTraveledHeroData.SelectedHero = SelectedHero;
        NewPlayerState->Kills = Kills;
        NewPlayerState->Assists = Assists;
        NewPlayerState->Deaths = Deaths;
    }
}
```

**注意：**虽然旧级别和新级别可以具有相同的 **PlayerState** 类，但更优雅的方法是为每个级别拥有不同的类，并且有一个共同的父类 **PlayerState** 类（它们从中继承），该类持有在级别之间传递的所有数据。

再考虑到这个功能用于在旅行和断开连接之间持久化数据，如果有一些数据你不想在旅行中持久化，但你希望它们在断开连接时持久化，怎么办？

这就是为什么 `APlayerState::Reset()` 被 `APlayerController::SeamlessTravelFrom()` 调用。应该重置而不是在旅行中保留的属性应该放在那里。这是该函数的默认实现：

PlayerState.cpp

```C++
Copy codevoid APlayerState::Reset()
{
    Super::Reset();
    SetScore(0);
    ForceNetUpdate();
}
```

如上所示，`Score` 属性被重置，因此它不会保留旅行记录，但会保留断开连接的记录。

让我们覆盖它，使其看起来像这样：

PlayerState.cpp

```C++
Copy codevoid AMyPlayerState::Reset()
{
    Super::Reset(); // This is called so we reset data chosen to be reset by default, e.g., Score

    Kills = 0;
    Assists = 0;
    Deaths = 0;
}
```

现在，当**无缝**旅行时：`击杀`、`助攻`和`死亡`将全部重置，但`选择的英雄`将被保留。然而，前面提到的三个属性在**断开连接**时不会重置。

**注意：** `APlayerState::CopyProperties()` 在 **无缝** 和 **困难** 旅行时被调用。旅行时，必须是 **无缝** 才能被称为无缝旅行。断开连接时，旅行根据定义是 **困难** 的，我们之前已经看到它被调用（除非 [我们让它不被调用](https://wizardcell.com/unreal/persistent-data/#the-better-more-reliable-way-to-stash-data-on-disconnection)）。

## 4. PlayerController[Permalink](https://wizardcell.com/unreal/persistent-data/#4-playercontroller)

一个 **PlayerController** 是 **Pawn** 和控制它的人类玩家之间的接口。**PlayerController** 本质上代表了人类玩家的意志。

### 这个Class在哪里存在？[Permalink](https://wizardcell.com/unreal/persistent-data/#where-does-this-class-exist-3)

这个类 **Actor** 存在于服务器上，复制到拥有的客户端，并且仅对他相关 (`bOnlyRelevantToOwner = true`)。因此，每个客户端只知道他自己的 **PlayerController**。

###  复制数据[Permalink](https://wizardcell.com/unreal/persistent-data/#copying-data-1)

数据从旧实例的 **Actor** 复制到新实例，前提是 **无缝** 旅行，并且 **仅** 在 **要么** 新的 **GameMode** 的 **PlayerController** 类与之前的 **不同**，**或者** 新的 **GameMode** 类是 `AGameModeBase` 的子类（而不是 `AGameMode`）。如果新的 **GameMode** 类是 **子类** 的 `AGameMode` **并且** 其 **PlayerController** 类与之前的 **相同**，则不进行数据复制，因为相同的 **Actor** 保持不变。数据复制过程在服务器上进行。

###  使用情况[Permalink](https://wizardcell.com/unreal/persistent-data/#usage-3)

- 在**无缝**旅行之间保持玩家特定数据。
- 在**PlayerController**和**PlayerCameraManager****Actor**实例之间，在**无缝**旅行时保持相同的整体。

###  示例用法[Permalink](https://wizardcell.com/unreal/persistent-data/#example-usage-3)

让我们快速查看一下负责数据保存的函数的文档：

GameModeBase.h

```C++
Copy code/**
 * Used to swap a viewport/connection's PlayerControllers when seamless traveling and the new GameMode's
 * controller class is different than the previous
 * includes network handling
 * @param OldPC - the old PC that should be discarded
 * @param NewPC - the new PC that should be used for the player
 */
virtual void SwapPlayerControllers(APlayerController* OldPC, APlayerController* NewPC);
```

快速查看这个函数的实现，我们可以知道哪些属性被保留：

GameModeBase.cpp

```C++
Copy codevoid AGameModeBase::SwapPlayerControllers(APlayerController*OldPC, APlayerController* NewPC)
{
    if (IsValid(OldPC) && IsValid(NewPC) && OldPC->Player != nullptr)
    {
        // move the Player to the new PC
        UPlayer* Player = OldPC->Player;
        NewPC->NetPlayerIndex = OldPC->NetPlayerIndex; //@warning: critical that this is first as SetPlayer() may trigger RPCs
        NewPC->NetConnection = OldPC->NetConnection;
        NewPC->SetReplicates(OldPC->GetIsReplicated());
        NewPC->SetPlayer(Player);
        NewPC->CopyRemoteRoleFrom(OldPC);

        K2_OnSwapPlayerControllers(OldPC, NewPC);

        ...
    }

    ...
}
```

请注意，上面的本地版本函数调用以下**蓝图**版本：

GameModeBase.h

```C++
Copy code/** Called when a PlayerController is swapped to a new one during seamless travel */
UFUNCTION(BlueprintImplementableEvent, Category=Game, meta=(DisplayName="OnSwapPlayerControllers", ScriptName="OnSwapPlayerControllers"))
void K2_OnSwapPlayerControllers(APlayerController* OldPC, APlayerController* NewPC);
```

**注意：** 上述函数必须在目标关卡的 **游戏模式** 类中被重写。

## 5. GetSeamlessTravelActorList[Permalink](https://wizardcell.com/unreal/persistent-data/#5-getseamlesstravelactorlist)

这个函数有两个版本，分别在两个不同的类中：**GameMode** 和 **PlayerController**。让我们看看前者的文档：

GameModeBase.h

```C++
Copy code/**
 * called on server during seamless level transitions to get the list of Actors that should be moved into the new level
 * PlayerControllers, Role < ROLE_Authority Actors, and any non-Actors that are inside an Actor that is in the list
 * (i.e. Object.Outer == Actor in the list)
 * are all automatically moved regardless of whether they're included here
 * only dynamic actors in the PersistentLevel may be moved (this includes all actors spawned during gameplay)
 * this is called for both parts of the transition because actors might change while in the middle (e.g. players might join or leave the game)
 * @see also PlayerController::GetSeamlessTravelActorList() (the function that's called on clients)
 * @param bToTransition true if we are going from old level to transition map, false if we are going from transition map to new level
 * @param ActorList (out) list of actors to maintain
 */
virtual void GetSeamlessTravelActorList(bool bToTransition, TArray<AActor*>& ActorList);
```

我们已经[看到](https://wizardcell.com/unreal/persistent-data/#persisting-data-across-seamless-travel)它用于将**对象**持久化到过渡和目标地图，因为它会被调用两次，一次是在到达过渡地图时，另一次是在到达目标地图时。可以保证在整个过程中**对象**不会被垃圾回收。

###  保存和检索数据[Permalink](https://wizardcell.com/unreal/persistent-data/#saving--retrieving-data-2)

这个选项特别之处在于，您不需要一个第三方**对象**来保存相关的**演员**的数据。您甚至不需要复制任何数据（只要您不手动销毁**演员**），因为**演员**本身几乎不需要任何努力就能持续存在。然而，有很大可能性指向我们持久生成的**演员**的**对象**并不是持久的，也就是说，它将被销毁并被垃圾回收，从而导致我们对持久**演员**的直接引用丢失。幸运的是，我们可以在本地代码中使用 `TActorRange<PersistentActorClass>` ，或者在蓝图中使用`GetAllActorsOfClass`来再次找到我们的持久**演员**，并重新建立链接。无论我们在新关卡中多早尝试找到它，它都会在那里，这也使得它非常适合初始化顺序。

###  使用情况[Permalink](https://wizardcell.com/unreal/persistent-data/#usage-4)

- 真正坚持**对象**几乎不费力。
- 初始化顺序很好。

#### AGameModeBase:: GetSeamlessTravelActorList[Permalink](https://wizardcell.com/unreal/persistent-data/#agamemodebase-getseamlesstravelactorlist)

- 在**对象**之间保持服务器端世界状态，以便在**无缝**旅行时跨越关卡。

#### APlayerController:: GetSeamlessTravelActorList[Permalink](https://wizardcell.com/unreal/persistent-data/#aplayercontroller-getseamlesstravelactorlist)

- 在无缝旅行时，在关卡之间保持与本地玩家（通常是客户端）相关的**对象**。

**注意：** **PlayerController** 函数版本可以在服务器端调用，正如我们之前[看到](https://wizardcell.com/unreal/persistent-data/#persistent-objects-on-server-to-destination-map)的那样，适用于监听服务器玩家。

###  示例用法[Permalink](https://wizardcell.com/unreal/persistent-data/#example-usage-4)

假设我们想要存储有关每个参加比赛的队伍的信息。一般存储比赛状态信息的**Actor**是**GameState**。但是，如果我们希望这些信息在关卡之间保持不变，以便在新比赛开始之前根据这些信息奖励玩家，那该怎么办？如果队伍不平衡，我们希望我们的平衡系统在新比赛开始之前自动平衡它们，又该怎么办呢？

我们已经提到过 [为什么](https://wizardcell.com/unreal/persistent-data/#should-they-be-kept-to-destination-map) 我们不应该将 **GameState** 持久化到目标地图。相反，我们将创建一个类似的复制品，始终相关的单例 **Actor**：

TeamSetup.h

```C++
Copy codeUSTRUCT()
struct FTeamInfo
{
    GENERATED_BODY()

    UPROPERTY()
    int32 TeamId;

    UPROPERTY()
    FText Name;
    
    UPROPERTY()
    int32 Score;

    void AddScore(int32 InScore)
    {
        Score += InScore;
    }
};

UCLASS()
class ATeamSetup : public AInfo
{
    GENERATED_BODY()

public:

    ATeamSetup(const FObjectInitializer& ObjectInitializer = FObjectInitializer::Get());

    UPROPERTY(Transient)
    TArray<FTeamInfo> Teams;
};
```

TeamSetup.cpp

```C++
Copy codeATeamSetup::ATeamSetup(const FObjectInitializer& ObjectInitializer)
    : Super(ObjectInitializer.DoNotCreateDefaultSubobject(TEXT("Sprite")))
{
    bReplicates = true;
    bAlwaysRelevant = true;
}
```

我们最终将拥有两个 **游戏模式**： `ALobbyGameMode` 和 `ACombatGameMode`。一个好的做法是将这两个类子类化为 `ABaseGameMode`，其中包含共享的内容，包括需要持久化的内容。在我们的案例中，我们将使 `ALobbyGameMode` 生成它，并缓存一个指向它的指针：

BaseGameMode.h

```C++
Copy code/** Used to setup teams and replicate teams related info to all clients */
UPROPERTY(Transient)
TObjectPtr<ATeamSetup> TeamSetup;

virtual void GetSeamlessTravelActorList(bool bToTransition, TArray<AActor*>& ActorList) override;
```

BaseGameMode.cpp

```C++
Copy codevoid ABaseGameMode::GetSeamlessTravelActorList(bool bToTransition, TArray<AActor*>& ActorList)
{
    Super::GetSeamlessTravelActorList(bToTransition, ActorList);

    ActorList.Add(TeamSetup);
}
```

BaseGameMode.cpp

```C++
Copy codevoid ABaseGameMode::GetSeamlessTravelActorList(bool bToTransition, TArray<AActor*>& ActorList)
{
    Super::GetSeamlessTravelActorList(bToTransition, ActorList);

    ActorList.Add(TeamSetup);
}
```

LobbyGameMode.h

```C++
Copy codeUCLASS()
class ALobbyGameMode : public AGameMode
{
    GENERATED_BODY()

public:

    virtual void PreInitializeComponents() override;
};
```

LobbyGameMode.cpp

```C++
Copy codevoid ALobbyGameMode::PreInitializeComponents()
{
    Super::PreInitializeComponents();

    FActorSpawnParameters SpawnInfo;
    SpawnInfo.Instigator = GetInstigator();
    SpawnInfo.ObjectFlags |= RF_Transient;  // We never want to save team setups into the map

    UWorld* World = GetWorld();
    TeamSetup = World->SpawnActor<ATeamSetup>(ATeamSetup::StaticClass(), SpawnInfo);
}
```

为了让我们的 `TeamSetup`**Actor** 对所有人都能轻松访问，我们将其传递给 `ACombatGameState`，该状态是复制的，并且始终与所有客户端相关。如我们之前 [提到](https://wizardcell.com/unreal/persistent-data/#saving--retrieving-data-2) 的，`ALobbyGameMode` 有一个指向我们正在持久化的 **Actor** 的指针，尽管它 [不会持久化到目标地图](https://wizardcell.com/unreal/persistent-data/#persistent-objects-on-server-to-transition-map-only)，这导致失去了对 `TeamSetup`**Actor** 的直接引用。为了重新建立链接，我们必须再次找到它：

CombatGameMode.h

```C++
Copy codeUCLASS()
class ACombatGameMode : public ABaseGameMode
{
    GENERATED_BODY()

public:
    /**
     * Initialize the GameState actor with default settings
     * called during PreInitializeComponents() of the GameMode after a GameState has been spawned
     * as well as during Reset()
     */
    virtual void InitGameState() override;
}
```

CombatGameMode.cpp

```C++
Copy codevoid ACombatGameMode::InitGameState()
{
    Super::InitGameState();

    for (ATeamSetup* MyTeamSetup : TActorRange<ATeamSetup>(GetWorld()))
    {
        TeamSetup = MyTeamSetup; // reestablish the linkage

        if(ACombatGameState* GS = GetGameState<ABTGameState>())
        {
            GS->TeamSetup = TeamSetup; // cache it in GameState so it's easily accessible client-side
        }
    }
}
```

请注意，我们在新的**游戏模式**被[实例化](https://docs.unrealengine.com/4.26/en-US/ProgrammingAndScripting/ProgrammingWithCPP/UnrealArchitecture/Actors/ActorLifecycle/)之前找到**演员**，因此它可以在`BeginPlay()`被调用之前很早就被找到，这使得它在初始化顺序上非常好，所以无论我们多早尝试找到它，它都在那里。

###  持久 HUD 示例[Permalink](https://wizardcell.com/unreal/persistent-data/#persistent-hud-example)

 即将到来 ![:tm:](https://github.githubassets.com/images/icons/emoji/unicode/2122.png)

## 6. SaveGame[Permalink](https://wizardcell.com/unreal/persistent-data/#6-savegame)

这个类作为一个保存游戏的基类 **对象**，可以用来保存游戏的状态。

### 这个Class在哪里存在？[Permalink](https://wizardcell.com/unreal/persistent-data/#where-does-this-class-exist-4)

这个类是本地创建的，即在您保存数据的地方创建。因此，它可以同时存在于服务器和客户端，但不支持任何类型的复制。

###  保存和检索数据[Permalink](https://wizardcell.com/unreal/persistent-data/#saving--retrieving-data-3)

一个**SaveGame****Object**/文件直接保存到您的磁盘，使其成为保存应该在游戏关闭后仍然存在的数据的绝佳类（这标志着**GameInstance**的生命周期结束，以及任何具有类似生命周期的子系统）。根据您的游戏大小，您可能会有多个**SaveGame****Objects**，因此跟踪它们变得棘手，如果管理不当，会变得相当混乱。因此，**GameInstance**可以作为我们所有**SaveGame****Objects**的管理器。如果您觉得这会使您的**GameInstance**类膨胀，您可以选择一个**GameInstance**子系统。这两种选择都很好，因为它们在游戏应用程序运行时是活跃的，并且几乎可以从任何地方轻松访问。数据可以在旅行或断开连接时保存，并在旅行结束或重新连接时检索/加载。

###  使用情况[Permalink](https://wizardcell.com/unreal/persistent-data/#usage-5)

- 保存玩家特定或世界状态的数据，以便在游戏退出时保持。
- 保存游戏用户设置（尽管通常它们保存在[专用文件配置](https://docs.unrealengine.com/4.27/en-US/API/Runtime/Engine/GameFramework/UGameUserSettings/)中）。

###  示例用法[Permalink](https://wizardcell.com/unreal/persistent-data/#example-usage-5)

我遇到了很多例子，不过我建议以下这些：

- [保存和加载您的游戏（官方文档）](https://docs.unrealengine.com/4.27/en-US/InteractiveExperiences/SaveGame/)
- [虚幻引擎 C++ 保存系统（汤姆·卢曼教程）](https://www.tomlooman.com/unreal-engine-cpp-save-system/)
- [SPUD: Steve 的持久虚拟数据库（完整保存系统插件）](https://github.com/sinbad/SPUD)

##  7. 游戏选项字符串[Permalink](https://wizardcell.com/unreal/persistent-data/#7-game-options-string)

虽然之前的方法围绕着**对象**，但这次的方法并不是这种类型。

我们已经提到选项字符串，它是所谓的 **URL** 的一部分，在 [**旅行类型**](https://wizardcell.com/unreal/persistent-data/#travel-types) 的上下文中。你可以看出，我们可以很好地利用它，在旅行时持久化数据。

**记住：** 进入游戏是一段旅程，特别是一次艰难的旅程。

###  URL 结构[Permalink](https://wizardcell.com/unreal/persistent-data/#url-structure)

这里是**参数**，一个**URL**由此组成：

EngineBaseTypes.h

```C++
Copy code// URL structure.
USTRUCT()
struct ENGINE_API FURL
{
    GENERATED_USTRUCT_BODY()

    // Protocol, i.e. "unreal" or "http".
    UPROPERTY()
    FString Protocol;

    // Optional hostname, i.e. "204.157.115.40" or "unreal.epicgames.com", blank if local.
    UPROPERTY()
    FString Host;

    // Optional host port.
    UPROPERTY()
    int32 Port;

    UPROPERTY()
    int32 Valid;

    // Map name, i.e. "SkyCity", default is "Entry".
    UPROPERTY()
    FString Map;

    // Optional place to download Map if client does not possess it
    UPROPERTY()
    FString RedirectURL;

    // Options.
    UPROPERTY()
    TArray<FString> Op;

    // Portal to enter through, default is "".
    UPROPERTY()
    FString Portal;

    // Statics.
    static FUrlConfig UrlConfig;
    static bool bDefaultsInitialized;

    ...
};
```

**网址** 可以传递给可执行文件，以强制游戏在启动时加载特定地图。这些也可以与 SERVER 或 EDITOR 模式结合使用，以运行带有特定地图的编辑器或服务器。传递 **网址** 是可选的，但必须紧跟在可执行文件名称或任何模式切换之后（如果存在）。

一个 **URL** 由 **两个部分** 组成：一个 **地图名称或服务器 IP 地址** 和一系列 **可选的附加参数**。地图名称 (`FURL.Map`) 可以是位于 Maps 目录中的任何地图。这里包含文件扩展名 (`.umap`) 是可选的。要加载在 Maps 目录中找不到的地图，可以使用绝对路径或从 Maps 目录的相对路径。在这种情况下，包含文件扩展名是强制性的。服务器 IP 地址 (`FURL.Host`) 是一个标准的四部分 IP 地址，由四个值（介于 0 和 255 之间）组成，值之间用句点分隔。附加选项 (`FURL.Op`) 通过将其附加到地图名称或服务器 IP 地址来指定。每个选项前面都有一个 `?`（作为分隔符），并可以用 `=` 设置值，即格式为： `?option1=value1?option2=value2` 。以 `-` 开头的选项将从缓存的 **URL** 选项中移除。

**注意：**任何添加的无意义字符（前导空格、重复的 `?`）通常会被跳过。其他字符是不允许的（双斜杠/反斜杠，任何组合，或 `\?`），这会导致无效的 **URL**（即 `FURL.Valid = 0`）。因此，您不应该尝试使其失败，而是只放入所需的内容。

###  URL 内置选项[Permalink](https://wizardcell.com/unreal/persistent-data/#url-built-in-options)

每个连接都有两个缓存的**URL**：

1. **世界 URL** (`UWorld.URL`): 缓存加载世界 URL。
2. **演示网址** (`FReplayHelper.DemoURL`): 缓存的回放网址。

下表包含了*所有*内置选项：

| 选项                                                         | 描述                                                     |                        世界网址选项？                        |                        演示网址选项？                        | 注意                                                         |
| :----------------------------------------------------------- | :------------------------------------------------------- | :----------------------------------------------------------: | :----------------------------------------------------------: | :----------------------------------------------------------- |
| **Game**                                                     | GameMode 类的别名。                                      | ![:heavy_check_mark:](https://github.githubassets.com/images/icons/emoji/unicode/2714.png) | ![:heavy_check_mark:](https://github.githubassets.com/images/icons/emoji/unicode/2714.png) | 覆盖默认。 别名在 `Project Settings->Maps & Modes->Default Modes->Advanced->Game Mode Class Aliases` 中设置。 |
| **Load**                                                     | 如果设置，加载的世界 URL 将不会被缓存。                  | ![:heavy_check_mark:](https://github.githubassets.com/images/icons/emoji/unicode/2714.png) |                                                              |                                                              |
| **Name**                                                     | 玩家/机器人名称。                                        | ![:heavy_check_mark:](https://github.githubassets.com/images/icons/emoji/unicode/2714.png) |                                                              | 长度限制为 20 个字符。                                       |
| **MaxPlayers**                                               | 服务器允许的最大玩家数量。                               | ![:heavy_check_mark:](https://github.githubassets.com/images/icons/emoji/unicode/2714.png) |                                                              |                                                              |
| **MaxSpectators**                                            | 服务器允许的最大观众人数。                               | ![:heavy_check_mark:](https://github.githubassets.com/images/icons/emoji/unicode/2714.png) |                                                              |                                                              |
| **SplitscreenCount**                                         | 允许从一个连接中分屏的玩家数量。                         | ![:heavy_check_mark:](https://github.githubassets.com/images/icons/emoji/unicode/2714.png) |                                                              |                                                              |
| **Listen**                                                   | 将服务器指定为监听服务器。                               | ![:heavy_check_mark:](https://github.githubassets.com/images/icons/emoji/unicode/2714.png) |                                                              |                                                              |
| **bIsLanMatch**                                              | 设置多人游戏是否在本地网络上。                           | ![:heavy_check_mark:](https://github.githubassets.com/images/icons/emoji/unicode/2714.png) |                                                              |                                                              |
| **bPassthrough**                                             | 设置此网络连接是否传递到 IpConnection。                  | ![:heavy_check_mark:](https://github.githubassets.com/images/icons/emoji/unicode/2714.png) |                                                              | 使用直通插座。                                               |
| **bUseIPSockets**                                            | 设置是否使用 IP 套接字。                                 | ![:heavy_check_mark:](https://github.githubassets.com/images/icons/emoji/unicode/2714.png) |                                                              |                                                              |
| **LAN**                                                      | 用于设置与局域网相关的设置。                             | ![:heavy_check_mark:](https://github.githubassets.com/images/icons/emoji/unicode/2714.png) |                                                              | 检索 `ConfiguredLanSpeed`。                                  |
| **bIsFromInvite**                                            | 指定加入的玩家是被邀请的。                               | ![:heavy_check_mark:](https://github.githubassets.com/images/icons/emoji/unicode/2714.png) |                                                              |                                                              |
| **SpectatorOnly**                                            | 以观众模式开始游戏。                                     | ![:heavy_check_mark:](https://github.githubassets.com/images/icons/emoji/unicode/2714.png) |                                                              |                                                              |
| **SkipSpawnSpectatorController**                             | 跳过生成演示观众。                                       |                                                              | ![:heavy_check_mark:](https://github.githubassets.com/images/icons/emoji/unicode/2714.png) |                                                              |
| **DemoRec**                                                  | 演示录音名称。                                           |                                                              | ![:heavy_check_mark:](https://github.githubassets.com/images/icons/emoji/unicode/2714.png) |                                                              |
| **DemoFriendlyName**                                         | 重放的描述，最好是人类可读的。                           |                                                              | ![:heavy_check_mark:](https://github.githubassets.com/images/icons/emoji/unicode/2714.png) |                                                              |
| **RecordMapChanges**                                         | 设置演示网络驱动程序是否记录地图更改/旅行。              |                                                              | ![:heavy_check_mark:](https://github.githubassets.com/images/icons/emoji/unicode/2714.png) |                                                              |
| [**ReplayStreamerOverride**](https://docs.unrealengine.com/en-US/TestingAndOptimization/ReplaySystem/Streamers/#demonetdriverfeatures) | 覆盖默认的 `FReplayHelper.ReplayStreamer`。              |                                                              | ![:heavy_check_mark:](https://github.githubassets.com/images/icons/emoji/unicode/2714.png) | 值：`真/是/开` 与 `假/否/关`。                               |
| **ReplayStreamerDemoPath**                                   | 更改存储演示的基本目录。                                 |                                                              | ![:heavy_check_mark:](https://github.githubassets.com/images/icons/emoji/unicode/2714.png) | 值：`真/是/开` 与 `假/否/关`。                               |
| **SkipToLevelIndex**                                         | 导致当前重放跳到具有指定索引的级别。                     |                                                              | ![:heavy_check_mark:](https://github.githubassets.com/images/icons/emoji/unicode/2714.png) | 从已使用的级别列表中。                                       |
| **AsyncLoadWorldOverride**                                   | 覆盖默认的异步世界加载 `CVarDemoAsyncLoadWorld` 值。     |                                                              | ![:heavy_check_mark:](https://github.githubassets.com/images/icons/emoji/unicode/2714.png) | 值：`真/是/开` 与 `假/否/关`。                               |
| **LevelPrefixOverride**                                      | 将此网络驱动程序使用的级别 ID/PIE 实例 ID 设置为。       | ![:heavy_check_mark:](https://github.githubassets.com/images/icons/emoji/unicode/2714.png) |                                                              |                                                              |
| **AuthTicket**                                               | 用于验证的令牌。                                         | ![:heavy_check_mark:](https://github.githubassets.com/images/icons/emoji/unicode/2714.png) |                                                              |                                                              |
| **EncryptionToken**                                          | 令牌，用于使服务器启动启用连接加密的过程。               | ![:heavy_check_mark:](https://github.githubassets.com/images/icons/emoji/unicode/2714.png) |                                                              | 更多信息[在这里](https://forums.unrealengine.com/t/how-to-enable-encryption-using-packet-handler-components/264938)。 |
| **NoTimeouts**                                               | 完全忽略超时。仅应在开发中使用。                         | ![:heavy_check_mark:](https://github.githubassets.com/images/icons/emoji/unicode/2714.png) |                                                              |                                                              |
| **Failed**                                                   | 旅行失败发生。                                           | ![:heavy_check_mark:](https://github.githubassets.com/images/icons/emoji/unicode/2714.png) |                                                              |                                                              |
| **Closed**                                                   | 与服务器的连接已关闭。                                   | ![:heavy_check_mark:](https://github.githubassets.com/images/icons/emoji/unicode/2714.png) |                                                              |                                                              |
| **Restart**                                                  | 重新使用我们上次旅行的 URL。                             | ![:heavy_check_mark:](https://github.githubassets.com/images/icons/emoji/unicode/2714.png) |                                                              |                                                              |
| **Quiet**                                                    |                                                          | ![:heavy_check_mark:](https://github.githubassets.com/images/icons/emoji/unicode/2714.png) |                                                              |                                                              |
| **SeamlessTravel**                                           | 将`ServerTravel`设置为无缝。                             | ![:heavy_check_mark:](https://github.githubassets.com/images/icons/emoji/unicode/2714.png) |                                                              | 覆盖默认设置（即将推出 ![:tm:](https://github.githubassets.com/images/icons/emoji/unicode/2122.png) ）。 |
| **NoSeamlessTravel**                                         | 将`ServerTravel`设置为非无缝。                           | ![:heavy_check_mark:](https://github.githubassets.com/images/icons/emoji/unicode/2714.png) |                                                              | 覆盖默认设置（即将推出 ![:tm:](https://github.githubassets.com/images/icons/emoji/unicode/2122.png) ）。 |
| **变异器**                                                   | 加载指定变异器的包。                                     | ![:heavy_check_mark:](https://github.githubassets.com/images/icons/emoji/unicode/2714.png) |                                                              | 更多信息 [在这里](https://unreal.fandom.com/wiki/Mutator) 和 [在这里](https://nerivec.github.io/old-ue4-wiki/pages/c-mutator-tutorial.html)。 |
| **BugLoc**                                                   | 将玩家移动到指定位置。                                   | ![:heavy_check_mark:](https://github.githubassets.com/images/icons/emoji/unicode/2714.png) |                                                              | e.g. `BugLoc=(X=1798.8569,Y=475.9513,Z=-8.8500)`             |
| **BugRot**                                                   | 将玩家设置为指定的旋转。                                 | ![:heavy_check_mark:](https://github.githubassets.com/images/icons/emoji/unicode/2714.png) |                                                              | e.g. `BugRot=(Pitch=-1978,Yaw=-7197,Roll=0)`                 |
| **CauseEvent**                                               | 在第一次滴答声后引发事件，以便为游戏生成玩家等提供机会。 | ![:heavy_check_mark:](https://github.githubassets.com/images/icons/emoji/unicode/2714.png) |                                                              |                                                              |
| **InitialConnectTimeout**                                    | 覆盖 `NetDriver.InitialConnectTimeout` 。                | ![:heavy_check_mark:](https://github.githubassets.com/images/icons/emoji/unicode/2714.png) |                                                              |                                                              |
| **ConnectTimeout**                                           | 覆盖 `NetDriver.ConnectTimeout`。                        | ![:heavy_check_mark:](https://github.githubassets.com/images/icons/emoji/unicode/2714.png) |                                                              |                                                              |

**注意：**像控制台命令一样，选项不区分大小写。

###  传递和解析数据[Permalink](https://wizardcell.com/unreal/persistent-data/#passing--parsing-data)

无论您选择哪个功能进行旅行，您都应该能够将一个 **URL** 作为参数传递。在本地代码中，该参数被称为： `URL`/`InURL`/`Cmd`。

在蓝图中，有两个主要功能驱动旅行：

- **开放级别** :

![OpenLevel](https://wizardcell.com//assets/blog/persistent-data/open-level.png)

本地函数是 `UGameplayStatics::OpenLevel()`。以下是它如何构建 **URL** :

GameplayStatics.cpp

```C++
Copy codevoid UGameplayStatics::OpenLevel(const UObject* WorldContextObject, FName LevelName, bool bAbsolute, FString Options)
{
    ...

    const ETravelType TravelType = (bAbsolute ? TRAVEL_Absolute : TRAVEL_Relative);
    FWorldContext &WorldContext = GEngine->GetWorldContextFromWorldChecked(World);
    FString Cmd = LevelName.ToString();
    if (Options.Len() > 0)
    {
        Cmd += FString(TEXT("?")) + Options;
    }
    FURL TestURL(&WorldContext.LastURL, *Cmd, TravelType);
        
    ...
}
```

现在我们得出结论，`Options` 参数对应于 `FURL.Op`。此外，您可以看到第一个选项前不需要加上 `?`，因为这已经为您完成了。

如前所述，`bAbsolute = true` 默认情况下会重置我们曾经使用的 `Options` 字符串，否则它会从上一个级别继承过来，即我们现在传递的 `Options` 字符串会附加到它上面（关于 [这个谜团](https://wizardcell.com/unreal/persistent-data/#the-enigmas) 的更多信息见下文）。

- **执行控制台命令** :

![ExecuteConsoleCommand](https://wizardcell.com//assets/blog/persistent-data/execute-console-command.png)

对于旅行，这就是`Command`通常的样子： `<TravelCommand> <MapName><OptionsString>` 。
 所以例如： `ServerTravel MyMap?Listen?Game=MyGameMode` 。

**注意：**`OptionsString` 被附加到 `MapName`。它以字符 `?` 开头。

但是等等，真的有必要每次旅行时都硬编码 `Options` 字符串吗？显然不是。感谢 [Cedric](https://cedric-neukirchen.net/) 提醒我注意以下函数：

LocalPlayer.h

```
Copy code/** 
 * Retrieves any game-specific login options for this player
 * if this function returns a non-empty string, the returned option or options be added
 * passed in to the level loading and connection code.  Options are in URL format,
 * key=value, with multiple options concatenated together with an & between each key/value pair
 * 
 * @return URL Option or options for this game, Empty string otherwise
 */
virtual FString GetGameLoginOptions() const { return TEXT(""); }
```

此功能允许您集中管理硬编码的 `Options` 字符串，因此您只需调用它即可检索待旅行的 `Options` 字符串。请注意，您必须添加自己的 **LocalPlayer** 类，并将其设置在 `Project Settings->General Settings->Default Classes` 中，然后您就可以覆盖该功能。

要解析选项字符串，您可以使用[一些函数](https://docs.unrealengine.com/en-US/BlueprintAPI/GameOptions/)。

**提示：** 请参阅之前提到的[本地](https://wizardcell.com/unreal/persistent-data/#native-travel-drivers)函数，以原生方式完成此操作。

###  谜团[Permalink](https://wizardcell.com/unreal/persistent-data/#the-enigmas)

我在途中面临了两个谜团：

**(1)** 你可能已经注意到 **GameMode** 缓存了选项字符串：

GameModeBase.h

```
Copy code/** Save options string and parse it when needed */
UPROPERTY(BlueprintReadOnly, Category=GameMode)
FString OptionsString;
```

我脑海中浮现的第一个问题是：“考虑到**GameMode**类仅存在于服务器上，这个字符串是如何在每个连接中缓存的？”

当地图第一次加载时，将调用以下函数：

GameModeBase.cpp

```
Copy codevoid AGameModeBase::InitGame(const FString& MapName, const FString& Options, FString& ErrorMessage)
{
    ...

    // Save Options for future use
    OptionsString = Options;

    ...
}
```

考虑到这是唯一缓存`AGameModeBase.OptionsString`的地方，我们得出结论：

- 在**监听服务器**设置的情况下：`OptionsString`属于主机玩家。

例如，假设一个玩家正在托管一个地图，即以监听服务器的方式加载。他可能想要使用以下参数调用以下函数：

![OpenLevelListen](https://wizardcell.com//assets/blog/persistent-data/open-level-listen.png)

考虑到他是第一次加载地图，那么 `OptionsString` 等于传递的参数 `Options`。其他加入地图的玩家不会影响它。那么他们的选项字符串缓存在哪里？

答案在于[连接过程](https://docs.unrealengine.com/4.27/en-US/InteractiveExperiences/Networking/Server/#connectionprocess)。任何尝试加入服务器的客户端将调用 `AGameModeBase::PreLogin(const FString& Options, ...)` ，该函数的参数是选项字符串。接下来调用的函数之一是：

GameModeBase.h

```
Copy code/**
 * Customize incoming player based on URL options
 *
 * @param NewPlayerController player logging in
 * @param UniqueId unique id for this player
 * @param Options URL options that came at login
 *
 */
virtual FString InitNewPlayer(APlayerController* NewPlayerController, const FUniqueNetIdRepl& UniqueId, const FString& Options, const FString& Portal = TEXT(""));
```

通过查看其实现，您将理解对于客户端，选项字符串是解析但不缓存的。我将留给您去查看它是如何解析**URL**选项的。

**注意：** `AGameModeBase::InitNewPlayer()` 和在此之前调用的登录功能 (`AGameModeBase::PreLogin()`/`AGameModeBase::Login()`) 仅在**硬**旅行时被调用。`AGameModeBase::PreLogin()` 是为尝试连接服务器的客户端连接调用的。`AGameModeBase::Login()` 是为每个被接受的客户端连接调用的，包括在存在的情况下的监听服务器连接。

- 在 **专用服务器** 设置的情况下：选项字符串属于服务器。对于客户端，它会有所不同，具体取决于他们使用的旅行命令。例如 `ServerTravel` 会将所有客户端与服务器相同的选项字符串一起旅行。如果您想要传递不同的选项字符串，您需要使用 `Travel` 或 `Open` 命令。

  

**(2)** 正如我们之前提到的，根据[旅行类型](https://wizardcell.com/unreal/persistent-data/#travel-types)，选项字符串可能会被重置。这到底意味着什么？

让我们看看之前的例子：一个玩家正在托管一个地图，即以监听服务器的方式加载。他可能想用设置的参数调用以下函数：

![OpenLevelListen](https://wizardcell.com//assets/blog/persistent-data/open-level-listen.png)

如您所见，`bAbsolute = true`，这意味着旅行类型是`TRAVEL_Absolute`，我们已经说过这意味着整个最后的**URL**被忽略，包括选项字符串。在我们的情况下，这是否意味着`Options`字符串参数被忽略？

答案显然是否定的，`Options` 并没有被忽略。原因是 **最后的 URL** 被忽略，而 `Options` 是我们正在使用的 **当前 URL** 的一部分。此外，忽略/重置它也没有意义，因为否则我们根本无法托管地图。

要全面了解情况，您需要查看以下结构：

Engine.h

```
Copy codeUSTRUCT()
struct FWorldContext
{
    GENERATED_USTRUCT_BODY()

    ...

    /** URL to travel to for pending client connect */
    FString TravelURL;

    /** TravelType for pending client connects */
    uint8 TravelType;

    /** URL the last time we traveled */
    UPROPERTY()
    struct FURL LastURL;

    /** last server we connected to (for "reconnect" command) */
    UPROPERTY()
    struct FURL LastRemoteURL;

    ...
};
```

如上所示，`FWorldContext.LasURL` 是最后一个 **URL**，而 `FWorldContext.TravelURL` 是当前的那个（客户端正在使用的）。关于该结构的文档可以在 [这里](https://github.com/EpicGames/UnrealEngine/blob/d9d435c9c280b99a6c679b517adedd3f4b02cfd7/Engine/Source/Runtime/Engine/Classes/Engine/Engine.h#L266) 找到。

现在举个例子，在我们旅行到 `MyMap` 之后，我们以这种方式旅行到 `MyOtherMap`：

![OpenLevelRelative](https://wizardcell.com//assets/blog/persistent-data/open-level-relative.png)

注意这次 `bAbsolute = false`，这意味着旅行的类型是 `TRAVEL_Relative`。如前所述，这意味着最后的 **URL** 被保留（我们仍然在同一服务器上），最后的选项字符串也被保留，它会被添加到我们正在旅行的当前选项字符串前面。因此，新的选项字符串将如下所示： `?MaxPlayers=3?Listen?Name=MyAwesomeName` 。

您可能已经注意到字符串开头缺少一个 `?Listen`。原因是引擎正在防止我们自讨苦吃，因此将其移除。

UnrealEngine.cpp

```
Copy codevoid UEngine::SetClientTravel( UWorld *InWorld, const TCHAR* NextURL, ETravelType InTravelType )
{
    FWorldContext &Context = GetWorldContextFromWorldChecked(InWorld);

    // set TravelURL.  Will be processed safely on the next tick in UGameEngine::Tick().
    Context.TravelURL    = NextURL;
    Context.TravelType   = InTravelType;

    // Prevent crashing the game by attempting to connect to own listen server
    if ( Context.LastURL.HasOption(TEXT("Listen")) )
    {
        Context.LastURL.RemoveOption(TEXT("Listen"));
    }
}
```

此函数适用于所有类型的旅行（包括断开连接，实际上也算是旅行），适用于任何进行旅行的客户端（包括作为主机加载的客户端）。

###  使用情况[Permalink](https://wizardcell.com/unreal/persistent-data/#usage-6)

- 在旅行时持久化原始数据类型（无论旅行类型如何）。
- 首次加载时将数据传递给服务器 (**hard** travel)。
-  快速检测。

###  示例用法[Permalink](https://wizardcell.com/unreal/persistent-data/#example-usage-6)

- 以下是通过命令行启动独立程序的示例：

UnrealEngine.cpp

```
Copy codeMyGame.exe /Game/Maps/MyMap
UnrealEditor.exe MyGame.uproject /Game/Maps/MyMap?game=MyGameMode -game
UnrealEditor.exe MyGame.uproject /Game/Maps/MyMap?listen -server
MyGame.exe 127.0.0.1
```

- 以下是一个玩家托管地图（按下 1），另一个玩家加入他（按下 2）的示例：

![HostAndJoin](https://wizardcell.com//assets/blog/persistent-data/host-and-join.png)

##  8. 数据库[Permalink](https://wizardcell.com/unreal/persistent-data/#8-database)